[["hugo.html", "Chapter 2 Hugo", " Chapter 2 Hugo 在本章中，我们将简要介绍 blogdown 所基于的静态站点生成器 Hugo (https://gohugo.io)。本章并不是要取代 Hugo 官方文档，而是为那些刚刚开始使用 Hugo 的人提供一个指南。如有疑问，请查阅 Hugo 官方文档。 "],["static-sites.html", "2.1 Static sites and Hugo", " 2.1 Static sites and Hugo 静态站点通常由 HTML 文件（具有可选的外部依赖项，如图像和 JavaScript 库）组成，并且无论谁访问网页，Web 服务器都会向 Web 浏览器发送完全相同的内容。当请求页面时，服务器上没有动态计算。相比之下，动态站点依赖服务器端语言来执行某些计算，并根据不同的条件发送可能不同的内容。通用语言是 PHP，动态站点的典型示例是网络论坛。例如，每个用户都有一个个人资料页面，但这通常并不意味着服务器为每个用户存储了不同的 HTML 个人资料页面。相反，服务器将从数据库中获取用户数据，并动态呈现个人资料页面。 对于静态站点，您访问的每个 URL 通常都会在服务器上存储相应的 HTML 文件，因此在向访问者提供文件之前无需进行任何计算。这意味着静态站点的响应时间往往比动态站点更快，而且它们也更容易部署，因为部署只是意味着将静态文件复制到服务器。动态站点通常依赖于数据库，您必须安装更多软件包才能为动态站点提供服务。有关静态站点的更多优点，请阅读 Hugo 网站上的 “Benefits of Static Site Generators” 页面。 现有的静态站点生成器有很多，包括 Hugo、Jekyll 和 Hexo 等。它们大多数可以构建通用网站，但通常用于构建博客。 我们喜爱 Hugo 的原因有很多，但有几个原因最为突出。与其他静态站点生成器不同，Hugo 的安装非常简单，因为它为大多数操作系统提供了一个不依赖的可执行文件（请参见 Section 1.1）。它还被设计为比同类静态站点生成器更快地呈现数百页内容，据报道可以在大约 1 毫秒内呈现单个页面。最后，Hugo 用户社区在 Hugo discussion forum 和 GitHub issues 上都非常活跃。 尽管我们认为 Hugo 是一款出色的静态站点生成器，但确实缺少一个且仅有一个主要功能：对 R Markdown 的支持。这基本上就是 blogdown 包的全部要点。1 这个缺失的功能意味着您无法在网页上使用 R 代码轻松生成结果，因为您只能使用静态 Markdown 文档。另外，Hugo 默认的 Markdown 引擎是 “Blackfriday”，功能不如 Pandoc。2 Hugo 使用特殊的文件和文件夹结构来创建您的网站（Figure 2.1）。本章的其余部分将提供有关以下文件和文件夹的更多详细信息： config.toml content/ static/ themes/ layouts/ FIGURE 2.1: Possible files and folders created when you create a new site using blogdown. 另一个动机是创建新页面或帖子的更简单方法。静态站点生成器通常提供创建新帖子的命令，但您通常必须在使用这些命令后打开并修改手动创建的新文件。我对此感到非常沮丧，因为我正在寻找一个图形用户界面，我可以在其中填写标题、作者、日期和有关页面的其他信息，然后我就可以立即开始编写内容。这就是为什么我提供了 RStudio 插件 “New Post” 和函数 blogdown::new_post()。在过去的几年里，每次我要手动或通过 Jekyll 命令行创建新帖子时，我都讨厌它。最后，在完成 RStudio 插件后，我又对博客上瘾了。↩︎ Pandoc 支持已添加到 Hugo pull request: https://github.com/gohugoio/hugo/pull/4060。不过，我认为支持相当有限，我建议您使用 R Markdown 格式，因为 Hugo 中提供了官方 Pandoc 支持，您无法自定义 Pandoc 命令行选项，渲染不会被缓存（它可能很慢），并且您将无法使用 bookdown 包中的任何 Markdown 扩展（例如对图形标题进行编号）。↩︎ "],["configuration.html", "2.2 Configuration", " 2.2 Configuration 您可能想要查看的第一个文件是根目录中的配置或 config 文件，您可以在其中设置站点的全局配置。它可能包含网站的标题和描述等选项，以及其他全局选项，例如社交网络的链接、导航菜单和网站的基本 URL。 生成站点时，Hugo 将首先搜索名为 config.toml 的文件。如果找不到，它将继续搜索 config.yaml。3 由于大多数 Hugo 主题都包含提供 config.toml 文件的示例站点，并且 TOML (Tom’s Obvious, Minimal Language) 格式似乎在 Hugo 社区 中更流行，我们这里主要讨论 config.toml。 我们建议您仅在配置文件中使用 TOML 语法（如果您愿意，也可以使用 YAML），并使用 YAML 作为 (R) Markdown 页面和帖子的 metadata 的数据格式，因为 R Markdown 和 blogdown 完全支持仅限 YAML。4 如果您的网站已经使用了 TOML，您可以使用 blogdown::hugo_convert(unsafe = TRUE) 将 TOML 数据转换为 YAML，但请首先确保您已备份该网站，因为它会覆盖您的网站 Markdown 文件。 Hugo 文档在其示例中没有一致地使用 TOML 或 YAML，这可能会令人困惑。将示例复制到您自己的网站时，请密切注意配置格式。 2.2.1 TOML Syntax 如果您不熟悉 TOML 语法，我们将提供简要概述，您可以阅读 full documentation 以了解详细信息。 TOML 由用等号分隔的键值对组成： key = value 当您想要编辑 TOML 文件中的配置时，只需更改 value 即可。字符串 Values 应放在引号中，而布尔 values 应小写且不包含任何内容。 例如，如果您想为您的网站指定标题 “My Awesome Site”，并使用相对 URLs 而不是默认的绝对 URLs，则您的 config.toml 文件中可能包含以下条目。 title = &quot;My Awesome Site&quot; relativeURLs = true 大多数网站的全局变量都是以这种方式输入到 config.toml 文件中的。 进一步深入您的 config 文件，您可能会注意到括号中的一些值，如下所示： [social] github = &quot;https://github.com/rstudio/blogdown&quot; twitter = &quot;https://twitter.com/rstudio&quot; 这是一个 TOML 语言的表格，Hugo 使用它们来填写站点内其他页面上的信息。例如，上表将填充站点模板中的 .Site.Social 变量（更多信息请参见 Section 2.5）。 最后，您可能会在双括号中找到一些值，如下所示： [[menu.main]] name = &quot;Blog&quot; url = &quot;/blog/&quot; [[menu.main]] name = &quot;Categories&quot; url = &quot;/categories/&quot; [[menu.main]] name = &quot;About&quot; url = &quot;/about/&quot; 在 TOML 中，双括号用于指示表数组。Hugo 将此信息解释为菜单。如果在 config.toml 文件中找到上述代码，则生成的网站将在网站主菜单中包含指向博客、类别和关于页面的链接。该菜单的位置和样式在其他地方指定，但每个菜单选项的名称以及每个部分的链接都在此处定义。 每个主题的 config.toml 文件都不同。确保当你选择一个主题时，你彻底阅读了它的文档，以了解每个配置选项的作用（更多关于主题的信息，请参见 Section 2.4）。 2.2.2 Options 您可以为 Hugo 设置的所有内置选项在 https://gohugo.io/overview/configuration/ 列出。您可以更改除 contentDir 之外的任何选项，它是硬编码到 blogdown 中的内容。我们的一般建议是，除非您了解后果，否则最好不要修改默认值。我们列出了您可能感兴趣的一些选项： baseURL: 通常您必须将此选项的值更改为您网站的基本 URL。某些 Hugo 主题可能在其示例站点中将其设置为 http://replace-this-with-your-hugo-site.com/ 或 http://www.example.com/，但请确保将其替换为您自己的 URL（有关发布网站和获取域名的更多信息，请参阅 Chapter 3 和 Appendix C）。请注意，如果您的网站要在域名的子路径下发布，则此选项可以是带有子路径的 URL，例如 http://www.example.com/docs/。 enableEmoji: 您可以将其设置为 true，以便您可以在 Markdown 中使用 :smile: 等 Emoji emoticons。 permalinks: 生成页面永久链接的规则。默认情况下，Hugo 使用 content/ 下的完整文件名来生成链接，例如，content/about.md 将呈现为 public/about/index.html，content/post/2015-07-23-foo.md 将呈现为 public/post/2015-07-23-foo/index.html，所以实际的链接是网站上的 /about/ 和 /post/2015-07-23-foo/。尽管不需要为永久链接设置自定义规则，但通常会看到 /YYYY/mm/dd/post-title/ 形式的链接。 Hugo 允许您使用有关源文件的多项信息来生成链接，例如日期（年月日）、标题和文件名等。链接可以独立于实际文件名。例如，您可以要求 Hugo 使用链接的日期和标题来呈现 content/post/ 下的页面： [permalinks] post = &quot;/:year/:month/:day/:title/&quot; 就我个人而言，我建议您使用 :slug 变量5 而不是 :title: [permalinks] post = &quot;/:year/:month/:day/:slug/&quot; 这是因为你的帖子标题可能会发生变化，而你可能不希望帖子的链接发生变化，否则你必须将旧链接重定向到新链接，并且会出现像 Disqus 评论这样的其他类型的麻烦。如果帖子的 YAML metadata 中未设置名为 slug 的字段，则 :slug 变量会回退到 :title 。您可以设置固定的 slug，以便帖子的链接始终固定，并且您可以自由地更新帖子的标题。 您可以在 https://gohugo.io/extras/permalinks/ 找到可在 permalinks 选项中使用的所有可能变量的列表。 publishDir: 您要在其下生成网站的目录。 theme: themes/ 下 Hugo 主题的目录名。 ignoreFiles: Hugo 在构建网站时忽略某些文件的文件名模式（正则表达式）列表。我建议您至少指定这些模式 [\"\\\\.Rmd$\", \"\\\\.Rmarkdown$\", \"_cache$\"]。您应该忽略 .Rmd 文件，因为 Hugo 应该只识别它们的输出文件（例如 .html 或 .md 文件）。后缀为 _cache 的目录应该被忽略，因为它们包含 Rmd 文件编译后的辅助文件，这些文件对 Hugo 来说是无用的。 uglyURLs: 默认情况下，Hugo 生成 “clean” URLs。这可能有点令人惊讶，并且要求您了解浏览器从服务器获取页面时 URL 的工作原理。基本上，Hugo 默认为 foo.md 生成 foo/index.html 而不是 foo.html，因为前者允许您通过 clean URL foo/ 访问页面，而不需要 index.html。大多数网络服务器都能理解 http://www.example.com/foo/ 之类的请求，并将在 foo/ 下向您显示 index.html。如果您更喜欢从 *.md 到 *.html 的严格映射，您可以通过将 uglyURLs 设置为 true 来启用 “ugly” URLs。 hasCJKLanguage: 如果您的网站主要是 CJK（中文、韩文和日文），我建议您将此选项设置为 true，以便 Hugo 的自动摘要和字数统计效果更好。 除了内置的 Hugo 选项外，您还可以在 config.toml 中设置其他任意选项。例如，很常见的是名为 params 的选项，它广泛应用于许多 Hugo 主题中。当您在 Hugo 主题中看到变量 .Site.Params.FOO 时，它表示您在 config.toml 中的 [params] 下设置的选项 FOO，例如 .Site.Params.author 是 Frida Gomam，具有以下配置文件： [params] author = &quot;Frida Gomam&quot; dateFormat = &quot;2006/01/02&quot; 所有这些选项的目标是避免对 Hugo 主题中的任何内容进行硬编码，以便用户可以轻松编辑单个配置文件以将主题应用到他们的网站，而不是浏览许多 HTML 文件并逐一进行更改。 Hugo 也支持 config.json，但 blogdown 不支持，所以我们不建议您使用它。↩︎ TOML 有它的优点，但我觉得它们在 Hugo 网站的背景下并不重要。当 YAML 代表 “另一种标记语言” 时，必须了解另一种语言 TOML 是一种痛苦。我不确定 XKCD 漫画是否适用于这种情况：https://xkcd.com/927/。↩︎ slug 只是一个字符串，可用于标识特定的帖子。即使标题改变，slug 也不会改变。例如，如果您决定将帖子的标题从 “I love blogdown” 更改为 “Why blogdown is the best package ever”，并且您在 URL 中使用了该帖子的标题，那么您的旧链接现在将被破坏。相反，如果您通过 slug（类似于 “blogdown-love”）指定 URL，那么您可以根据需要多次更改标题，并且不会出现任何损坏的链接。↩︎ "],["content.html", "2.3 Content", " 2.3 Content content/ 目录的结构可以是任意的。常见的结构是 content/ 根目录下有一些静态页面，以及一个包含博客文章的子目录 post/： ├── _index.md ├── about.md ├── vitae.md ├── post/ │ ├── 2017-01-01-foo.md │ ├── 2017-01-02-bar.md │ └── ... └── ... 2.3.1 YAML metadata 每个页面都应以 YAML metadata 开头，指定标题、日期、作者、类别、标签等信息。根据您使用的特定 Hugo 主题和模板，其中一些字段可能是可选的。 在所有 YAML 字段中，我们希望引起您的注意： draft: 您可以通过在其 YAML metadata 中设置 draft: true 将文档标记为草稿。如果网站是通过 blogdown::build_site() 或 blogdown::hugo_build() 构建的，则不会呈现草稿帖子，但会在本地预览模式下呈现（请参阅 Section D.3）。 publishdate: 您可以指定发布帖子的未来日期。与草稿帖子类似，未来的帖子仅以本地预览模式呈现。 weight: 该字段可以采用数值来告诉 Hugo 排序时页面的顺序，例如，当您生成目录下所有页面的列表时，并且两个帖子具有相同的日期，您可以为它们分配不同的权重在列表中获取您想要的顺序。 slug: 作为 URL 尾部的字符串。当您为永久 URL 定义自定义规则时，它特别有用（请参阅 Section 2.2.2）。 2.3.2 Body 正如我们在 Section 1.6 中提到的，您的帖子可以用 R Markdown 或普通 Markdown 编写。当您编写帖子正文时，请注意两种格式之间的语法差异。 2.3.3 Shortcode 除了所有 Markdown 功能之外，Hugo 还提供了一个名为 “shortcodes” 的有用功能。您可以在帖子正文中使用 shortcode。当 Hugo 渲染帖子时，它可以根据您传递给 shortcode 的参数自动生成 HTML 片段。这很方便，因为您不必在帖子中键入或嵌入大量 HTML 代码。例如，Hugo 有一个内置的 shortcode，用于嵌入 Twitter 卡片。通常，这是在页面上嵌入 Twitter 卡（Figure 2.2）的方式： &lt;blockquote class=&quot;twitter-tweet&quot;&gt; &lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;Anyone know of an R package for interfacing with Alexa Skills? &lt;a href=&quot;https://twitter.com/thosjleeper&quot;&gt;@thosjleeper&lt;/a&gt; &lt;a href=&quot;https://twitter.com/xieyihui&quot;&gt;@xieyihui&lt;/a&gt; &lt;a href=&quot;https://twitter.com/drob&quot;&gt;@drob&lt;/a&gt; &lt;a href=&quot;https://twitter.com/JennyBryan&quot;&gt;@JennyBryan&lt;/a&gt; &lt;a href=&quot;https://twitter.com/HoloMarkeD&quot;&gt;@HoloMarkeD&lt;/a&gt; ? &lt;/p&gt; &amp;mdash; Jeff Leek (@jtleek) &lt;a href=&quot;https://twitter.com/jtleek/status/852205086956818432&quot;&gt; April 12, 2017 &lt;/a&gt; &lt;/blockquote&gt; &lt;script async src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt; &lt;/script&gt; FIGURE 2.2: A tweet by Jeff Leek. 如果您使用 shortcode，您在 Markdown 源文档中只需要： {{&lt; tweet user=&quot;jtleek&quot;, id=&quot;852205086956818432&quot; &gt;}} 基本上，您只需将推文的用户名和 ID 传递给名为 tweet 的 shortcode。6 Hugo 将自动获取推文并为您呈现 HTML 片段。有关 shortcodes 的更多信息，请参阅 https://gohugo.io/extras/shortcodes/。 Shortcodes 应该仅适用于纯 Markdown 文档。要在 R Markdown 中使用 shortcodes 而不是普通 Markdown，您必须调用函数 blogdown::shortcode()，例如， ```{r echo=FALSE} blogdown::shortcode( &quot;tweet&quot;, user = &quot;jtleek&quot;, id = &quot;852205086956818432&quot; ) ``` Hugo v0.89.0 之前，只需要传递 ID 即可。由于 Twitter 自 2021 年底开始要求用户名，这意味着如果您想使用 Twitter shortcode，则必须使用 Hugo &gt;= 0.89.0 并提供用户名。不幸的是，对于旧版本的 Hugo，shortcode 将被破坏。↩︎ "],["themes.html", "2.4 Themes", " 2.4 Themes Hugo 主题是模板文件和可选网站资源（例如 CSS 和 JavaScript 文件）的集合。简而言之，主题定义了通过模板呈现源内容后您的网站的外观。 Hugo 在 https://themes.gohugo.io 上提供了大量用户贡献的主题。除非您是经验丰富的网页设计师，否则最好从此处的现有主题开始。这些主题的质量和复杂性差异很大，您应该谨慎选择。例如，您可以查看某个主题存储库在 GitHub 上的星星数量，以及该存储库是否仍然相对活跃。长时间（例如几年）未更新的主题可能仍适用于更高版本的 Hugo，也可能不适用于。您必须仔细测试它们。 在本节中，我们将解释 blogdown 中的默认主题是如何工作的，这也可能会给您一些关于如何开始使用其他主题的想法。 2.4.1 The default theme blogdown 中的默认主题 hugo-lithium 托管在 GitHub 上：https://github.com/yihui/hugo-lithium。它最初是由 Jonathan Rutheiser 编写的，我对其进行了一些修改。这个主题适合那些喜欢简约风格，想要建立一个只有几个页面和一些博客文章的网站的人。 通常，GitHub 上的主题存储库有一个 README 文件，该文件也用作主题的文档。阅读完后，下一个要查找的文件是 exampleSite 目录下的 config.toml，其中包含基于此主题的网站的示例配置。如果主题没有 README 文件或 exampleSite 目录，您可能不应该使用它。 主题 hugo-lithium 的 config.toml 包含以下选项： baseurl = &quot;/&quot; relativeurls = false languageCode = &quot;en-us&quot; title = &quot;A Hugo website&quot; theme = &quot;hugo-lithium&quot; ignoreFiles = [&quot;\\\\.Rmd$&quot;, &quot;\\\\.Rmarkdown&quot;, &quot;_files$&quot;, &quot;_cache$&quot;] [permalinks] post = &quot;/:year/:month/:day/:slug/&quot; [[menu.main]] name = &quot;About&quot; url = &quot;/about/&quot; [[menu.main]] name = &quot;GitHub&quot; url = &quot;https://github.com/rstudio/blogdown&quot; [[menu.main]] name = &quot;Twitter&quot; url = &quot;https://twitter.com/rstudio&quot; [params] description = &quot;A website built through Hugo and blogdown.&quot; highlightjsVersion = &quot;9.12.0&quot; highlightjsCDN = &quot;//cdnjs.cloudflare.com/ajax/libs&quot; highlightjsLang = [&quot;r&quot;, &quot;yaml&quot;] highlightjsTheme = &quot;github&quot; MathJaxCDN = &quot;//cdnjs.cloudflare.com/ajax/libs&quot; MathJaxVersion = &quot;2.7.5&quot; [params.logo] url = &quot;logo.png&quot; width = 50 height = 50 alt = &quot;Logo&quot; 其中一些选项可能很容易理解，而另一些可能需要解释： baseurl: 当您拥有网站的域名后，您可以稍后配置此选项。不要忘记结尾的斜杠。 relativeurls: 这是可选的。仅当您打算通过文件查看器在本地查看您的网站时，您可能才需要将其设置为 true，例如，双击 HTML 文件并在浏览器中查看它。该选项在 Hugo 中默认为 false，这意味着您的网站必须通过 Web 服务器查看，例如 blogdown::serve_site() 提供了本地 Web 服务器，因此当 relativeurls = false 时您可以在本地预览您的网站。 title: 您网站的标题。通常，它显示在网络浏览器的标题栏或页面选项卡上。 theme: 主题的目录名称。更改主题时需要非常小心，因为一个主题在配置方面可能与另一个主题截然不同。不同的主题很可能不适用于您当前的 config.toml。同样，您必须阅读主题的文档才能了解支持或需要哪些选项。 ignoreFiles and permalinks: 这些选项已在 Section 2.2.2 中进行了解释。 menu: 此选项列表指定顶部菜单项的文本和 URL。见 Figure ?? 获取示例页面。您可以更改或添加更多菜单项。如果您想排序项目，您可以为每个项目分配一个 weight，例如， [[menu.main]] name = &quot;Home&quot; url = &quot;/&quot; weight = 1 [[menu.main]] name = &quot;About&quot; url = &quot;/about/&quot; weight = 2 [[menu.main]] name = &quot;GitHub&quot; url = &quot;https://github.com/rstudio/blogdown&quot; weight = 3 [[menu.main]] name = &quot;CV&quot; url = &quot;/vitae/&quot; weight = 4 [[menu.main]] name = &quot;Twitter&quot; url = &quot;https://twitter.com/rstudio&quot; weight = 5 上面的例子中，我添加了一个菜单项 CV，URL 为 /vitae/，在 content/ 目录下应该有对应的源文件 vitae.md 来生成页面 /vitae/index.html，所以链接会真正发挥作用。 params: 主题的其他参数。 description: 您网站的简短描述。它在网页上不可见（您只能从 HTML 源代码中看到它），但应该向搜索引擎提供有关您网站的提示。 highlightjs*: 这些选项用于配置 JavaScript library highlight.js 以对网页上的代码块进行语法高亮显示。您可以更改版本（例如，9.12.0）、CND host（例如，使用 cdnjs: //cdnjs.cloudflare.com/ajax/libs）、添加更多语言（例如，[\"r\", \"yaml\", \"tex\"]），并更改主题（例如，atom-one-light）。请参阅 https://highlightjs.org/static/demo/ 了解 highlight.js 支持的所有语言和主题。 MathJax*: JavaScript library MathJax 可以在网页上呈现 LaTeX 数学表达式。与 highlightjsCDN 类似，您可以指定 MathJax 的 CDN host，例如 //cdnjs.cloudflare.com/ajax/libs，也可以指定 MathJax 的版本。 logo: 用于定义网站 logo 的选项列表。默认使用 static/ 目录下的 logo.png 图片。 如果你想成为一名主题开发人员并完全了解有关这些选项的所有技术细节，你必须了解 Hugo 模板，我们将在 Section 2.5 中介绍。 "],["templates.html", "2.5 Templates", " 2.5 Templates A Hugo theme consists of two major components: templates, and web assets. The former is essential, and tells Hugo how to render a page.7 The latter is optional but also important. It typically consists of CSS and JavaScript files, as well as other assets like images and videos. These assets determine the appearance and functionality of your website, and some may be embedded in the content of your web pages. You can learn more about Hugo templates from the official documentation (https://gohugo.io/templates/overview/). There are a great many different types of templates. To make it easier for you to master the key ideas, I created a very minimal Hugo theme, which covers most functionalities that an average user may need, but the total number of lines is only about 150, so we can talk about all the source code of this theme in the following subsection. 2.5.1 A minimal example XMin is a Hugo theme I wrote from scratch in about 12 hours. Roughly half an hour was spent on templates, 3.5 hours were spent on tweaking the CSS styles, and 8 hours were spent on the documentation (https://xmin.yihui.org). I think this may be a representative case of how much time you would spend on each part when designing a theme. It is perhaps our nature to spend much more time on cosmetic stuff like CSS than essential stuff like templates. Meanwhile, coding is often easier than documentation. We will show the source code of the XMin theme. Because the theme may be updated occasionally in the future, you may follow this link to obtain a fixed version that we will talk about in this section: https://github.com/yihui/hugo-xmin/tree/4bb305. Below is a tree view of all files and directories in the theme: hugo-xmin/ ├── LICENSE.md ├── README.md ├── archetypes │ └── default.md ├── layouts │ ├── 404.html │ ├── _default │ │ ├── list.html │ │ ├── single.html │ │ └── terms.html │ └── partials │ ├── foot_custom.html │ ├── footer.html │ ├── head_custom.html │ └── header.html ├── static │ └── css │ ├── fonts.css │ └── style.css └── exampleSite ├── config.toml ├── content │ ├── _index.md │ ├── about.md │ ├── note │ │ ├── 2017-06-13-a-quick-note.md │ │ └── 2017-06-14-another-note.md │ └── post │ ├── 2015-07-23-lorem-ipsum.md │ └── 2016-02-14-hello-markdown.md ├── layouts │ └── partials │ └── foot_custom.html └── public └── ... LICENSE.md and README.md are not required components of a theme, but you definitely should choose a license for your source code so that other people can properly use your code, and a README can be the brief documentation of your software. The file archetypes/default.md defines the default template based on which users can create new posts. In this theme, default.md only provided empty YAML metadata: --- --- The most important directories of a theme are layouts/ and static/. HTML templates are stored under layouts/, and assets are stored under static/. To understand layouts/, you must know some basics about HTML (see Section B.1) because the templates under this directory are mostly HTML documents or fragments. There are many possible types of subdirectories under layouts/, but we are only going to introduce two here: _default/ and partials/. The _default/ directory is where you put the default templates for your web pages. In the XMin theme, we have three templates: single.html, list.html, and terms.html. single.html is a template for rendering single pages. A single page basically corresponds to a Markdown document under content/, and it contains both the (YAML) metadata and content. Typically we want to render the page title, author, date, and the content. Below is the source code of XMin’s single.html: {{ partial &quot;header.html&quot; . }} &lt;div class=&quot;article-meta&quot;&gt; &lt;h1&gt;&lt;span class=&quot;title&quot;&gt;{{ .Title }}&lt;/span&gt;&lt;/h1&gt; {{ with .Params.author }} &lt;h2 class=&quot;author&quot;&gt;{{ . }}&lt;/h2&gt; {{ end }} {{ if .Params.date }} &lt;h2 class=&quot;date&quot;&gt;{{ .Date.Format &quot;2006/01/02&quot; }}&lt;/h2&gt; {{ end }} &lt;/div&gt; &lt;main&gt; {{ .Content }} &lt;/main&gt; {{ partial &quot;footer.html&quot; . }} You see a lot of pairs of double curly braces {{}}, and that is how you program the templates using Hugo’s variables and functions. The template starts with a partial template header.html, for which you will see the source code soon. For now, you can imagine it as all the HTML tags before the body of your page (e.g., &lt;html&gt;&lt;head&gt;). Partial templates are mainly for reusing HTML code. For example, all HTML pages may share very similar &lt;head&gt;&lt;/head&gt; tags, and you can factor out the common parts into partial templates. The metadata of a page is included in a &lt;div&gt; element with the class article-meta. We recommend that you assign classes to HTML elements when designing templates, so that it will be easier to apply CSS styles to these elements using class names. In a template, you have access to many variables provided by Hugo, e.g., the .Title variable stores the value of the page title, and we write the title in a &lt;span&gt; in a first-level header &lt;h1&gt;. Similarly, the author and date are written in &lt;h2&gt;, but only if they are provided in the YAML metadata. The syntax {{ with FOO }}{{ . }}{{ end }} is a shorthand of {{if FOO }}{{ FOO }}{{ end }}, i.e., it saves you the effort of typing the expression FOO twice by using {{ . }}. The method .Format can be applied to a date object, and in this theme, we format dates in the form YYYY/mm/dd (2006/01/02 is the way to specify the format in Go). Then we show the content of a page, which is stored in the variable .Content. The content is wrapped in a semantic HTML tag &lt;main&gt;. The template is finished after we include another partial template footer.html (source code to be shown shortly). To make it easier to understand how a template works, we show a minimal example post below: --- title: Hello World author: Frida Gomam date: 2017-06-19 --- A single paragraph. Using the template single.html, it will be converted to an HTML page with source code that looks more or less like this (with the header and footer omitted): &lt;div class=&quot;article-meta&quot;&gt; &lt;h1&gt;&lt;span class=&quot;title&quot;&gt;Hello World&lt;/span&gt;&lt;/h1&gt; &lt;h2 class=&quot;author&quot;&gt;Frida Gomam&lt;/h2&gt; &lt;h2 class=&quot;date&quot;&gt;2017/06/19&lt;/h2&gt; &lt;/div&gt; &lt;main&gt; &lt;p&gt;A single paragraph.&lt;/p&gt; &lt;/main&gt; For a full example of a single page, you may see https://xmin.yihui.org/about/. list.html is the template for rendering lists of pages, such as a list of blog posts, or a list of pages within a category or tag. Here is its source code: {{ partial &quot;header.html&quot; . }} {{if not .IsHome }} &lt;h1&gt;{{ .Title }}&lt;/h1&gt; {{ end }} {{ .Content }} &lt;ul&gt; {{ range (where .Data.Pages &quot;Section&quot; &quot;!=&quot; &quot;&quot;) }} &lt;li&gt; &lt;span class=&quot;date&quot;&gt;{{ .Date.Format &quot;2006/01/02&quot; }}&lt;/span&gt; &lt;a href=&quot;{{ .URL }}&quot;&gt;{{ .Title }}&lt;/a&gt; &lt;/li&gt; {{ end }} &lt;/ul&gt; {{ partial &quot;footer.html&quot; . }} Again, it uses two partial templates header.html and footer.html. The expression {{if not .IsHome }} means, if this list is not the home page, show the page title. This is because I do not want to display the title on the homepage. It is just my personal preference. You can certainly display the title in &lt;h1&gt; on the home page if you want. The {{ .Content }} shows the content of the list. Please note that typically .Content is empty, which may be surprising. This is because a list page is not generated from a source Markdown file by default. However, there is an exception. When you write a special Markdown file _index.md under a directory corresponding to the list name, the .Content of the list will be the content of this Markdown file. For example, you can define the content of your homepage in content/_index.md, and the content of the post list page under content/post/_index.md. Next we generate the list using a loop (range) through all pages filtered by the condition that the section of a page should not be empty. “Section” in Hugo means the first-level subdirectory name under content/. For example, the section of content/post/foo.md is post. Therefore the filter means that we will list all pages under subdirectories of content/. This will exclude pages under the root content/ directory, such as content/about.md. Please note that the variable .Data is dynamic, and its value changes according to the specific list you want to generate. For example, the list page https://xmin.yihui.org/post/ only contains pages under content/post/, and https://xmin.yihui.org/note/ only contains pages under content/note/. These list pages are automatically generated by Hugo, and you do not need to explicitly loop through the sections post and note. That is, a single template list.html will generate multiple lists of pages according to the sections and taxonomy terms (e.g., categories and tags) you have on your website. The list items are represented by the HTML tags &lt;li&gt; in &lt;ul&gt;. Each item consists of the date, link, and title of a page. You may see https://xmin.yihui.org/post/ for a full example of a list page. terms.html is the template for the home page of taxonomy terms. For example, you can use it to generate the full list of categories or tags. The source code is below: {{ partial &quot;header.html&quot; . }} &lt;h1&gt;{{ .Title }}&lt;/h1&gt; &lt;ul class=&quot;terms&quot;&gt; {{ range $key, $value := .Data.Terms }} &lt;li&gt; &lt;a href=&#39;{{ (print &quot;/&quot; $.Data.Plural &quot;/&quot; $key) | relURL }}&#39;&gt; {{ $key }} &lt;/a&gt; ({{ len $value }}) &lt;/li&gt; {{ end }} &lt;/ul&gt; {{ partial &quot;footer.html&quot; . }} Similar to list.html, it also uses a loop. The variable .Data.Terms stores all terms under a taxonomy, e.g., all category names. You can think of it as a named list in R (called a map in Go), with the names being the terms and the values being lists of pages. The variable $key denotes the term and $value denotes the list of pages associated with this term. What we render in each &lt;li&gt; is a link to the term page as well as the count of posts that used this term (len is a Go function that returns the length of an object). Hugo automatically renders all taxonomy pages, and the path names are the plural forms of the taxonomies, e.g., https://xmin.yihui.org/categories/ and https://xmin.yihui.org/tags/. That is the meaning of .Data.Plural. The leading $ is required because we are inside a loop, and need to access variables from the outside scope. The link of the term is passed to the Hugo function relURL via a pipe | to make it relative, which is good practice because relative links are more portable (independent of the domain name). The partials/ directory is the place to put the HTML fragments to be reused by other templates via the partial function. We have four partial templates under this directory: header.html main defines the &lt;head&gt; tag and the navigation menu in the &lt;nav&gt; tag. &lt;!DOCTYPE html&gt; &lt;html lang=&quot;{{ .Site.LanguageCode }}&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;{{ .Title }} | {{ .Site.Title }}&lt;/title&gt; &lt;link href=&#39;{{ &quot;/css/style.css&quot; | relURL }}&#39; rel=&quot;stylesheet&quot; /&gt; &lt;link href=&#39;{{ &quot;/css/fonts.css&quot; | relURL }}&#39; rel=&quot;stylesheet&quot; /&gt; {{ partial &quot;head_custom.html&quot; . }} &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;ul class=&quot;menu&quot;&gt; {{ range .Site.Menus.main }} &lt;li&gt;&lt;a href=&quot;{{ .URL | relURL }}&quot;&gt;{{ .Name }}&lt;/a&gt;&lt;/li&gt; {{ end }} &lt;/ul&gt; &lt;hr/&gt; &lt;/nav&gt; The &lt;head&gt; area should be easy to understand if you are familiar with HTML. Note that we also included a partial template head_custom.html, which is empty in this theme, but it will make it much easier for users to add customized code to &lt;head&gt; without rewriting the whole template. See Section 2.6 for more details. The navigation menu is essentially a list, and each item of the list is read from the variable .Site.Menus.main. This means users can define the menu in config.toml, e.g., [[menu.main]] name = &quot;Home&quot; url = &quot;/&quot; [[menu.main]] name = &quot;About&quot; url = &quot;/about/&quot; It will generate a menu like this: &lt;ul class=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/about/&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; Hugo has a powerful menu system, and we only used the simplest type of menu in this theme. If you are interested in more features like nested menus, please see the full documentation at http://gohugo.io/extras/menus/. footer.html defines the footer area of a page and closes the HTML document: &lt;footer&gt; {{ partial &quot;foot_custom.html&quot; . }} {{ with .Site.Params.footer }} &lt;hr/&gt; {{ . | markdownify }} {{ end }} &lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; The purpose of the partial template foot_custom.html is the same as head_custom.html; that is, to allow the user to add customized code to the &lt;footer&gt; without rewriting the whole template. Lastly, we use the variable .Site.Params.footer to generate a page footer. Note we used the with function again. Recall that the syntax {{ with .Site.Params.footer }}{{ . }}{{ end }} is a shorthand for {{if .Site.Params.footer }}{{ .Site.Params.footer }}{{ end }}. This syntax saves you from typing the expression .Site.Params.footer twice by using {{ . }} as a placeholder for the variable footer, which is defined as a site parameter in our config.toml file. The additional function markdownify can convert Markdown to HTML (i.e., {{ . | markdownify }}. Altogether, this sequence means we can define a footer option using Markdown under params in config.toml, e.g., [params] footer = &quot;&amp;copy; [Yihui Xie](https://yihui.org) 2017&quot; There is a special template 404.html, which Hugo uses to create the 404 page (when a page is not found, this page is displayed): {{ partial &quot;header.html&quot; . }} 404 NOT FOUND {{ partial &quot;footer.html&quot; . }} With all templates above, we will be able to generate a website from Markdown source files. You are unlikely to be satisfied with the website, however, because the HTML elements are not styled at all, and the default appearance may not look appealing to most people. You may have noticed that in header.html, we have included two CSS files, /css/style.css and /css/fonts.css. You can find many existing open-source CSS frameworks online that may be applied to a Hugo theme. For example, the most popular CSS framework may be Bootstrap: http://getbootstrap.com. When I was designing XMin, I wondered how far I could go without using any of these existing frameworks, because they are usually very big. For example, bootstrap.css has nearly 10000 lines of code when not minimized. It turned out that I was able to get a satisfactory appearance with about 50 lines of CSS, which I will explain in detail below: style.css defines all styles except the typefaces: body { max-width: 800px; margin: auto; padding: 1em; line-height: 1.5em; } The maximum width of the page body is set to 800 pixels because an excessively wide page is difficult to read (800 is an arbitrary threshold that I picked). The body is centered using the CSS trick margin: auto, which means the top, right, bottom, and left margins are automatic. When a block element’s left and right margins are auto, it will be centered. /* header and footer areas */ .menu li { display: inline-block; } .article-meta, .menu a { text-decoration: none; background: #eee; padding: 5px; border-radius: 5px; } .menu, .article-meta, footer { text-align: center; } .title { font-size: 1.1em; } footer a { text-decoration: none; } hr { border-style: dashed; color: #ddd; } Remember that our menu element is a list &lt;ul class=\"menu\"&gt; defined in header.html. I changed the default display style of &lt;li&gt; within the menu to inline-block, so that they will be laid out from left to right as inline elements, instead of being stacked vertically as a bullet list (the default behavior). For links (&lt;a&gt;) in the menu and the metadata area of an article, the default text decoration (underlines) is removed, and a light background color is applied. The border radius is set to 5 pixels so that you can see a subtle round-corner rectangle behind each link. The horizontal rule (&lt;hr&gt;) is set to a dashed light-gray line to make it less prominent on a page. These rules are used to separate the article body from the header and footer areas. /* code */ pre { border: 1px solid #ddd; box-shadow: 5px 5px 5px #eee; padding: 1em; overflow-x: auto; } code { background: #f9f9f9; } pre code { background: none; } For code blocks (&lt;pre&gt;), I apply light gray borders with drop-shadow effects. Every inline code element has a very light gray background. These decorations are merely out of my own peculiar interest and emphasis in code. /* misc elements */ img, iframe, video { max-width: 100%; } main { hyphens: auto; } blockquote { background: #f9f9f9; border-left: 5px solid #ccc; padding: 3px 1em 3px; } table { margin: auto; border-top: 1px solid #666; border-bottom: 1px solid #666; } table thead th { border-bottom: 1px solid #ddd; } th, td { padding: 5px; } tr:nth-child(even) { background: #eee } Embedded elements like images and videos that exceed the page margin are often ugly, so I restrict their maximum width to 100%. Hyphenation is turned on for words in &lt;main&gt;. Blockquotes have a gray left sidebar and a light gray background. Tables are centered by default, with only three horizontal rules: the top and bottom borders of the table, and the bottom border of the table head. Table rows are striped to make it easier to read the table especially when the table is wide. fonts.css is a separate style sheet because it plays a critical role in the appearance of a website, and it is very likely that you will want to customize this file. In most cases, your readers will spend the most time on reading the text on your pages, so it is important to make the text comfortable to read. I’m not an expert in web design, and I just picked Palatino for the body and Lucida Console or Monaco (whichever is available in your system) for the code. It is common to use Google web fonts nowadays. You may try some web fonts and see if you like any of them. body { font-family: &quot;Palatino Linotype&quot;, &quot;Book Antiqua&quot;, Palatino, serif; } code { font-family: &quot;Lucida Console&quot;, Monaco, monospace; font-size: 85%; } The two CSS files are placed under the static/css/ directory of the theme. In the HTML template header.html, the path /css/style.css refers to the file static/css/style.css. Lastly, this theme provided an example site under exampleSite/. The directory structure may be a little confusing because this is a theme instead of a website. In practice, everything under exampleSite/ should be under the root directory of a website, and the top-level hugo-xmin/ directory should be under the themes/ directory of this website, i.e., ├── config.toml ├── content/ ├── ... ├── themes/ │ └── hugo-xmin/ │ └── ... The example site provides a sample config.toml, a home page _index.md, an about page about.md, two posts under note/ and two under post/. It also overrides the foot_custom.html in the theme. 2.5.2 Implementing more features The XMin is actually a highly functional theme, but we understand that it may be too minimal for you. There are a few commonly used features (intentionally) missing in this theme, and we will teach you how to add them by yourself if desired. All these features and the source code can be applied to other themes, too. Enable Google Analytics. Hugo has provided a built-in partial template. For XMin, you can add {{ template &quot;_internal/google_analytics.html&quot; . }} to layouts/partials/foot_custom.html under the root directory of your website (instead of themes/hugo-xmin/), and configure googleAnalytics in the config.toml. See https://github.com/yihui/hugo-xmin/pull/3 for details, and the HTML source of this page for the JavaScript rendered from the template: https://deploy-preview-3--hugo-xmin.netlify.com. Enable Disqus comments. Similar to Google Analytics, you can add the built-in template {{ template &quot;_internal/disqus.html&quot; . }} to foot_custom.html, and configure the Disqus shortname in config.toml. See https://github.com/yihui/hugo-xmin/pull/4 for details, and a preview at https://deploy-preview-4--hugo-xmin.netlify.com. Enable syntax highlighting via highlight.js. Add this to head_custom.html &lt;link href=&quot;//YOUR-CDN-LINK/styles/github.min.css&quot; rel=&quot;stylesheet&quot;&gt; and this to foot_custom.html: &lt;script src=&quot;//YOUR-CDN-LINK/highlight.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//YOUR-CDN-LINK/languages/r.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; hljs.configure({languages: []}); hljs.initHighlightingOnLoad(); &lt;/script&gt; Remember to replace YOUR-CDN-LINK with the link to your preferred CDN host of highlight.js, e.g., cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0. For more information about highlight.js, please see its homepage: https://highlightjs.org. If you need to use other CDN hosts, cdnjs.com is a good choice: https://cdnjs.com/libraries/highlight.js You can also see which languages and CSS themes are supported there. You may see https://github.com/yihui/hugo-xmin/pull/5 for an actual implementation, and a sample page with syntax highlighting at https://deploy-preview-5--hugo-xmin.netlify.com/post/2016/02/14/a-plain-markdown-post/. Support math expressions through MathJax. Add the code below to foot_custom.html. &lt;script src=&quot;//yihui.org/js/math-code.js&quot;&gt;&lt;/script&gt; &lt;script async src=&quot;//YOUR-CDN-LINK/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt; &lt;/script&gt; This requires substantial knowledge of JavaScript and familiarity with MathJax to fully understand the code above, and we will leave the explanation of the code to Section B.3. Remember to replace YOUR-CDN-LINK with the link to your preferred CDN host of MathJax, e.g., cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5. Show the table of contents (TOC). To show a TOC for R Markdown posts, you only need to add the output format blogdown::html_page with the option toc: true to YAML: output: blogdown::html_page: toc: true For plain Markdown posts, you have to modify the template single.html. The TOC of a post is stored in the Hugo template variable .TableOfContents. You may want an option to control whether to show the TOC, e.g., you may add an option toc: true to the YAML metadata of a Markdown post to show the TOC. The code below can be added before the content of a post in single.html: {{ if .Params.toc }} {{ .TableOfContents }} {{ end }} See https://github.com/yihui/hugo-xmin/pull/7 for an implementation with examples. Display categories and tags in a post if provided in its YAML. Add the code below where you want to place the categories and tags in single.html, e.g., in &lt;div class=\"article-meta\"&gt;&lt;/div&gt;. &lt;p class=&quot;terms&quot;&gt; {{ range $i := (slice &quot;categories&quot; &quot;tags&quot;) }} {{ with ($.Param $i) }} {{ $i | title }}: {{ range $k := . }} &lt;a href=&#39;{{ relURL (print &quot;/&quot; $i &quot;/&quot; $k | urlize) }}&#39;&gt;{{$k}}&lt;/a&gt; {{ end }} {{ end }} {{ end }} &lt;/p&gt; Basically the code loops through the YAML metadata fields categories and tags, and for each field, its value is obtained from .Param, then we use an inside loop to write out the terms with links of the form &lt;a href=\"/tags/foo/\"&gt;foo&lt;/a&gt;. You may see https://github.com/yihui/hugo-xmin/pull/2 for the complete implementation and a preview at https://deploy-preview-2--hugo-xmin.netlify.com/post/2016/02/14/a-plain-markdown-post/. Add pagination. When you have a large number of posts on a website, you may not want to display the full list on a single page, but show N posts (e.g., N = 10) per page. It is easy to add pagination to a website using Hugo’s built-in functions and templates. Instead of looping through all posts in a list template (e.g., range .Data.Pages), you paginate the full list of posts using the function .Paginate (e.g., range (.Paginate .Data.Pages)). Below is a template fragment that you may insert to your template file list.html: &lt;ul&gt; {{ $paginator := .Paginate .Data.Pages }} {{ range $paginator.Pages }} &lt;li&gt; &lt;span class=&quot;date&quot;&gt;{{ .Date.Format &quot;2006/01/02&quot; }}&lt;/span&gt; &lt;a href=&quot;{{ .URL }}&quot;&gt;{{ .Title }}&lt;/a&gt; &lt;/li&gt; {{ end }} &lt;/ul&gt; {{ template &quot;_internal/pagination.html&quot; . }} See https://github.com/yihui/hugo-xmin/pull/16 for a full implementation. Add a GitHub Edit button or link to a page. If none of the above features look exciting to you (which would not surprise me), this little feature is really a great example of showing you the power of plain-text files and static websites, when combined with GitHub (or other services that support the online editing of plain-text files). I believe it would be difficult, if not impossible, to implement this feature in dynamic website frameworks like WordPress. Basically, when you browse any text files in a repository on GitHub, you can edit them right on the page by hitting the Edit button (see Figure 2.3 for an example) if you have a GitHub account. If you have write access to the repository, you can commit the changes directly online, otherwise GitHub will fork the repository for you automatically, so that you can edit the file in your own repository, and GitHub will guide you to create a pull request to the original repository. When the original owner sees the pull request, he/she can see the changes you made and decide whether to accept them or not or ask you to make further changes. Although the terminology “pull request” is highly confusing to beginners,8 it is probably the single greatest feature invented by GitHub, because it makes it so much easier for people to make contributions. What is really handy is that all you need is a URL of a fixed form to edit a file on GitHub: https://github.com/USER/REPO/edit/BRANCH/PATH/TO/FILE. For example, https://github.com/rbind/yihui/edit/master/content/knitr/faq.md, where USER is rbind, REPO is yihui, BRANCH is master, and the file path is content/knitr/faq.md. The key to implementing this feature is the variable .File.Path, which gives us the source file path of a page under content/, e.g., post/foo.md. If your website only uses plain Markdown files, the implementation will be very simple. I omitted the full GitHub URL in ... below, of which an example could be https://github.com/rbind/yihui/edit/master/content/. {{ with .File.Path }} &lt;a href=&quot;https://github.com/.../{{ . }}&quot;&gt;Edit this page&lt;/a&gt; {{ end }} However, the case is a little more complicated for blogdown users, when R Markdown posts are involved. You cannot just use .File.Path because it actually points to the .html output file from an .Rmd file, whereas the .Rmd file is the actual source file. The Edit button or link should not point to the .html file. Below is the complete implementation that you may add to a template file depending on where you want to show the Edit link (e.g., footer.html): {{ if .File.Path }} {{ $Rmd := (print .File.BaseFileName &quot;.Rmd&quot;) }} {{ if (where (readDir (print &quot;content/&quot; .File.Dir)) &quot;Name&quot; $Rmd) }} {{ $.Scratch.Set &quot;FilePath&quot; (print .File.Dir $Rmd) }} {{ else }} {{ $.Scratch.Set &quot;FilePath&quot; .File.Path }} {{ end }} {{ with .Site.Params.GithubEdit}} &lt;a href=&#39;{{ . }}{{ $.Scratch.Get &quot;FilePath&quot; }}&#39;&gt;Edit this page&lt;/a&gt; {{ end }} {{ end }} The basic logic is that for a file, if the same filename with the extension .Rmd exists, we will point the Edit link to the Rmd file. First, we define a variable $Rmd to be the filename with the .Rmd extension. Then we check if it exists. Unfortunately, there is no function in Hugo like file.exists() in R, so we have to use a hack: list all files under the directory and see if the Rmd file is in the list. $.Scratch is the way to dynamically store and obtain variables in Hugo templates. Most variables in Hugo are read-only, and you have to use $.Scratch when you want to modify a variable. We set a variable FilePath in $.Scratch, whose value is the full path to the Rmd file when the Rmd file exists, and the path to the Markdown source file otherwise. Finally, we concatenate a custom option GithubEdit in config.toml with the file path to complete the Edit link &lt;a&gt;. Here is an example of the option in config.toml: [params] GithubEdit = &quot;https://github.com/rbind/yihui/edit/master/content/&quot; Please note that if you use Hugo on Windows to build and deploy your site, you may have to change the file path separators from backslashes to forward slashes, e.g., you may need {{ $.Scratch.Set \"FilePath\" (replace ($.Scratch.Get \"FilePath\") \"\\\\\" \"/\") }} in the template. To avoid this complication, we do not recommend that you deploy your site through Windows (see Chapter 3 for deployment methods). You may see https://github.com/yihui/hugo-xmin/pull/6 for an actual implementation with R Markdown examples, and see the footer of this page for the Edit link: https://deploy-preview-6--hugo-xmin.netlify.com. You can actually see a link in the footer of every page, except the lists of pages (because they do not have source files). FIGURE 2.3: Edit a text file online on GitHub. After you digest the XMin theme and the implementations of additional features, it should be much easier to understand other people’s templates. There are a large number of Hugo themes but the primary differences among them are often in styles. The basic components of templates are often similar. The most common functionality of templates is to render HTML pages, but there can also be special templates, for example, for RSS feeds and sitemaps, which are XML files.↩︎ In my opinion, it really should be called “merge request” instead.↩︎ "],["custom-layouts.html", "2.6 Custom layouts", " 2.6 Custom layouts It is very likely that you want to customize a theme unless you designed it. The most straightforward way is to simply make changes directly in the theme,9 but the problem is that a Hugo theme may be constantly updated by its original author for improvements or bug fixes. Similar to the “you break it, you buy it” policy (the Pottery Barn rule), once you touch someone else’s source code, you will be responsible for its future maintenance, and the original author should not be responsible for the changes you made on your side. That means it may not be easy to pull future updates of this theme to your website (you have to carefully read the changes and make sure they do not conflict with your changes), but if you are completely satisfied with the current state of the theme and do not want future updates, it is fine to modify the theme files directly. A theme author who is aware of the fact that users may customize their theme will typically provide two ways: one is to provide options in config.toml, so that you can change these options without touching the template files; the other is to leave a few lightweight template files under layouts/ in the theme, so that you can override them without touching the core template files. Take the XMin theme for example: I have two empty HTML files head_custom.html and foot_custom.html under layouts/partials/ in the theme. The former will be added inside &lt;head&gt;&lt;/head&gt; of a page, e.g., you can load JavaScript libraries or include CSS style sheets via &lt;link&gt;. The latter will be added before the footer of a page, e.g., you may load additional JavaScript libraries or embed Disqus comments there. The way that you customize these two files is not to edit them directly in the theme folder, but to create a directory layouts/partials/ under the root directory of your website, e.g., your directory structure may look like this: your-website/ ├── config.toml ├── ... ├── themes/ │ └── hugo-xmin/ │ ├── ... │ └── layouts/ │ ├── ... │ └── partials │ ├── foot_custom.html │ ├── footer.html │ ├── head_custom.html │ └── header.html └── layouts └── partials ├── foot_custom.html └── head_custom.html All files under layouts/ under the root directory will override files with the same relative paths under themes/hugo-xmin/layouts/, e.g., the file layouts/partials/foot_custom.html, when provided, will override themes/hugo-xmin/layouts/partials/foot_custom.html. That means you only need to create and maintain at most two files under layouts/ instead of maintaining all files under themes/. Note that this overriding mechanism applies to all files under layouts/, and is not limited to the partials/ directory. It also applies to any Hugo theme that you actually use for your website, and is not limited to hugo-xmin. If you are new to web development, be careful changing content within the theme. Minor changes like colors and font sizes can be found within the CSS files of the theme and can be altered simply with minimal risk of breaking the theme’s functionality.↩︎ "],["static-files.html", "2.7 Static files", " 2.7 Static files All files under the static/ directory are copied to public/ when Hugo renders a website. This directory is often used to store static web assets like images, CSS, and JavaScript files. For example, an image static/foo/bar.png can be embedded in your post using the Markdown syntax ![](/foo/bar.png).10 Usually a theme has a static/ folder, and you can partially override its files using the same mechanism as overriding layouts/ files, i.e., static/file will override themes/theme-name/static/file. In the XMin theme, I have two CSS files style.css and fonts.css. The former is the main style sheet, and the latter is a quite small file to define typefaces only. You may want to define your own typefaces, and you can only provide a static/css/fonts.css to override the one in the theme, e.g., body { font-family: &quot;Comic Sans MS&quot;, cursive, sans-serif; } code { font-family: &quot;Courier New&quot;, Courier, monospace; } To R Markdown users, another important application of the static/ directory is to build Rmd documents with custom output formats, i.e., Rmd documents not using the blogdown::html_page() format (see Section 1.6). For example, you can generate a PDF or presentations from Rmd documents under this directory, so that Hugo will not post-process them but simply copies them to public/ for publishing. To build these Rmd files, you must provide a custom build script R/build.R (see Section D.9). You can write a single line of code in this script: blogdown::build_dir(&quot;static&quot;) The function build_dir() finds all Rmd files under a directory, and calls rmarkdown::render() to build them to the output formats specified in the YAML metadata of the Rmd files. If your Rmd files should not be rendered by a simple rmarkdown::render() call, you are free to provide your own code to render them in R/build.R. There is a built-in caching mechanism in the function build_dir(): an Rmd file will not be compiled if it is older than its output file(s). If you do not want this behavior, you can force all Rmd files to be recompiled every time: build_dir(force = TRUE). I have provided a minimal example in the GitHub repository yihui/blogdown-static, where you can find two Rmd examples under the static/ directory. One is an HTML5 presentation based on the xaringan package, and the other is a PDF document based on bookdown. You need to be cautious about arbitrary files under static/, due to Hugo’s overriding mechanism. That is, everything under static/ will be copied to public/. You need to make sure that the files you render under static/ will not conflict with those files automatically generated by Hugo from content/. For example, if you have a source file content/about.md and an Rmd file static/about/index.Rmd at the same time, the HTML output from the latter will overwrite the former (both Hugo and you will generate an output file with the same name public/about/index.html). The link of the image depends on your baseurl setting in config.toml. If it does not contain a subpath, /foo/bar.png will be the link of the image, otherwise you may have to adjust it, e.g., for baseurl = \"http://example.com/subpath/\", the link to the image should be /subpath/foo/bar.png.↩︎ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
