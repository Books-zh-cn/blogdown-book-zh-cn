[["hugo.html", "Chapter 2 Hugo", " Chapter 2 Hugo 在本章中，我们将简要介绍 blogdown 所基于的静态站点生成器 Hugo (https://gohugo.io)。本章并不是要取代 Hugo 官方文档，而是为那些刚刚开始使用 Hugo 的人提供一个指南。如有疑问，请查阅 Hugo 官方文档。 "],["static-sites.html", "2.1 Static sites and Hugo", " 2.1 Static sites and Hugo 静态站点通常由 HTML 文件（具有可选的外部依赖项，如图像和 JavaScript 库）组成，并且无论谁访问网页，Web 服务器都会向 Web 浏览器发送完全相同的内容。当请求页面时，服务器上没有动态计算。相比之下，动态站点依赖服务器端语言来执行某些计算，并根据不同的条件发送可能不同的内容。通用语言是 PHP，动态站点的典型示例是网络论坛。例如，每个用户都有一个个人资料页面，但这通常并不意味着服务器为每个用户存储了不同的 HTML 个人资料页面。相反，服务器将从数据库中获取用户数据，并动态呈现个人资料页面。 对于静态站点，您访问的每个 URL 通常都会在服务器上存储相应的 HTML 文件，因此在向访问者提供文件之前无需进行任何计算。这意味着静态站点的响应时间往往比动态站点更快，而且它们也更容易部署，因为部署只是意味着将静态文件复制到服务器。动态站点通常依赖于数据库，您必须安装更多软件包才能为动态站点提供服务。有关静态站点的更多优点，请阅读 Hugo 网站上的 “Benefits of Static Site Generators” 页面。 现有的静态站点生成器有很多，包括 Hugo、Jekyll 和 Hexo 等。它们大多数可以构建通用网站，但通常用于构建博客。 我们喜爱 Hugo 的原因有很多，但有几个原因最为突出。与其他静态站点生成器不同，Hugo 的安装非常简单，因为它为大多数操作系统提供了一个不依赖的可执行文件（请参见 Section 1.1）。它还被设计为比同类静态站点生成器更快地呈现数百页内容，据报道可以在大约 1 毫秒内呈现单个页面。最后，Hugo 用户社区在 Hugo discussion forum 和 GitHub issues 上都非常活跃。 尽管我们认为 Hugo 是一款出色的静态站点生成器，但确实缺少一个且仅有一个主要功能：对 R Markdown 的支持。这基本上就是 blogdown 包的全部要点。1 这个缺失的功能意味着您无法在网页上使用 R 代码轻松生成结果，因为您只能使用静态 Markdown 文档。另外，Hugo 默认的 Markdown 引擎是 “Blackfriday”，功能不如 Pandoc。2 Hugo 使用特殊的文件和文件夹结构来创建您的网站（Figure 2.1）。本章的其余部分将提供有关以下文件和文件夹的更多详细信息： config.toml content/ static/ themes/ layouts/ FIGURE 2.1: Possible files and folders created when you create a new site using blogdown. 另一个动机是创建新页面或帖子的更简单方法。静态站点生成器通常提供创建新帖子的命令，但您通常必须在使用这些命令后打开并修改手动创建的新文件。我对此感到非常沮丧，因为我正在寻找一个图形用户界面，我可以在其中填写标题、作者、日期和有关页面的其他信息，然后我就可以立即开始编写内容。这就是为什么我提供了 RStudio 插件 “New Post” 和函数 blogdown::new_post()。在过去的几年里，每次我要手动或通过 Jekyll 命令行创建新帖子时，我都讨厌它。最后，在完成 RStudio 插件后，我又对博客上瘾了。↩︎ Pandoc 支持已添加到 Hugo pull request: https://github.com/gohugoio/hugo/pull/4060。不过，我认为支持相当有限，我建议您使用 R Markdown 格式，因为 Hugo 中提供了官方 Pandoc 支持，您无法自定义 Pandoc 命令行选项，渲染不会被缓存（它可能很慢），并且您将无法使用 bookdown 包中的任何 Markdown 扩展（例如对图形标题进行编号）。↩︎ "],["configuration.html", "2.2 Configuration", " 2.2 Configuration 您可能想要查看的第一个文件是根目录中的配置或 config 文件，您可以在其中设置站点的全局配置。它可能包含网站的标题和描述等选项，以及其他全局选项，例如社交网络的链接、导航菜单和网站的基本 URL。 生成站点时，Hugo 将首先搜索名为 config.toml 的文件。如果找不到，它将继续搜索 config.yaml。3 由于大多数 Hugo 主题都包含提供 config.toml 文件的示例站点，并且 TOML (Tom’s Obvious, Minimal Language) 格式似乎在 Hugo 社区 中更流行，我们这里主要讨论 config.toml。 我们建议您仅在配置文件中使用 TOML 语法（如果您愿意，也可以使用 YAML），并使用 YAML 作为 (R) Markdown 页面和帖子的 metadata 的数据格式，因为 R Markdown 和 blogdown 完全支持仅限 YAML。4 如果您的网站已经使用了 TOML，您可以使用 blogdown::hugo_convert(unsafe = TRUE) 将 TOML 数据转换为 YAML，但请首先确保您已备份该网站，因为它会覆盖您的网站 Markdown 文件。 Hugo 文档在其示例中没有一致地使用 TOML 或 YAML，这可能会令人困惑。将示例复制到您自己的网站时，请密切注意配置格式。 2.2.1 TOML Syntax 如果您不熟悉 TOML 语法，我们将提供简要概述，您可以阅读 full documentation 以了解详细信息。 TOML 由用等号分隔的键值对组成： key = value 当您想要编辑 TOML 文件中的配置时，只需更改 value 即可。字符串 Values 应放在引号中，而布尔 values 应小写且不包含任何内容。 例如，如果您想为您的网站指定标题 “My Awesome Site”，并使用相对 URLs 而不是默认的绝对 URLs，则您的 config.toml 文件中可能包含以下条目。 title = &quot;My Awesome Site&quot; relativeURLs = true 大多数网站的全局变量都是以这种方式输入到 config.toml 文件中的。 进一步深入您的 config 文件，您可能会注意到括号中的一些值，如下所示： [social] github = &quot;https://github.com/rstudio/blogdown&quot; twitter = &quot;https://twitter.com/rstudio&quot; 这是一个 TOML 语言的表格，Hugo 使用它们来填写站点内其他页面上的信息。例如，上表将填充站点模板中的 .Site.Social 变量（更多信息请参见 Section 2.5）。 最后，您可能会在双括号中找到一些值，如下所示： [[menu.main]] name = &quot;Blog&quot; url = &quot;/blog/&quot; [[menu.main]] name = &quot;Categories&quot; url = &quot;/categories/&quot; [[menu.main]] name = &quot;About&quot; url = &quot;/about/&quot; 在 TOML 中，双括号用于指示表数组。Hugo 将此信息解释为菜单。如果在 config.toml 文件中找到上述代码，则生成的网站将在网站主菜单中包含指向博客、类别和关于页面的链接。该菜单的位置和样式在其他地方指定，但每个菜单选项的名称以及每个部分的链接都在此处定义。 每个主题的 config.toml 文件都不同。确保当你选择一个主题时，你彻底阅读了它的文档，以了解每个配置选项的作用（更多关于主题的信息，请参见 Section 2.4）。 2.2.2 Options 您可以为 Hugo 设置的所有内置选项在 https://gohugo.io/overview/configuration/ 列出。您可以更改除 contentDir 之外的任何选项，它是硬编码到 blogdown 中的内容。我们的一般建议是，除非您了解后果，否则最好不要修改默认值。我们列出了您可能感兴趣的一些选项： baseURL: 通常您必须将此选项的值更改为您网站的基本 URL。某些 Hugo 主题可能在其示例站点中将其设置为 http://replace-this-with-your-hugo-site.com/ 或 http://www.example.com/，但请确保将其替换为您自己的 URL（有关发布网站和获取域名的更多信息，请参阅 Chapter 3 和 Appendix C）。请注意，如果您的网站要在域名的子路径下发布，则此选项可以是带有子路径的 URL，例如 http://www.example.com/docs/。 enableEmoji: 您可以将其设置为 true，以便您可以在 Markdown 中使用 :smile: 等 Emoji emoticons。 permalinks: 生成页面永久链接的规则。默认情况下，Hugo 使用 content/ 下的完整文件名来生成链接，例如，content/about.md 将呈现为 public/about/index.html，content/post/2015-07-23-foo.md 将呈现为 public/post/2015-07-23-foo/index.html，所以实际的链接是网站上的 /about/ 和 /post/2015-07-23-foo/。尽管不需要为永久链接设置自定义规则，但通常会看到 /YYYY/mm/dd/post-title/ 形式的链接。 Hugo 允许您使用有关源文件的多项信息来生成链接，例如日期（年月日）、标题和文件名等。链接可以独立于实际文件名。例如，您可以要求 Hugo 使用链接的日期和标题来呈现 content/post/ 下的页面： [permalinks] post = &quot;/:year/:month/:day/:title/&quot; 就我个人而言，我建议您使用 :slug 变量5 而不是 :title: [permalinks] post = &quot;/:year/:month/:day/:slug/&quot; 这是因为你的帖子标题可能会发生变化，而你可能不希望帖子的链接发生变化，否则你必须将旧链接重定向到新链接，并且会出现像 Disqus 评论这样的其他类型的麻烦。如果帖子的 YAML metadata 中未设置名为 slug 的字段，则 :slug 变量会回退到 :title 。您可以设置固定的 slug，以便帖子的链接始终固定，并且您可以自由地更新帖子的标题。 您可以在 https://gohugo.io/extras/permalinks/ 找到可在 permalinks 选项中使用的所有可能变量的列表。 publishDir: 您要在其下生成网站的目录。 theme: themes/ 下 Hugo 主题的目录名。 ignoreFiles: Hugo 在构建网站时忽略某些文件的文件名模式（正则表达式）列表。我建议您至少指定这些模式 [\"\\\\.Rmd$\", \"\\\\.Rmarkdown$\", \"_cache$\"]。您应该忽略 .Rmd 文件，因为 Hugo 应该只识别它们的输出文件（例如 .html 或 .md 文件）。后缀为 _cache 的目录应该被忽略，因为它们包含 Rmd 文件编译后的辅助文件，这些文件对 Hugo 来说是无用的。 uglyURLs: 默认情况下，Hugo 生成 “clean” URLs。这可能有点令人惊讶，并且要求您了解浏览器从服务器获取页面时 URL 的工作原理。基本上，Hugo 默认为 foo.md 生成 foo/index.html 而不是 foo.html，因为前者允许您通过 clean URL foo/ 访问页面，而不需要 index.html。大多数网络服务器都能理解 http://www.example.com/foo/ 之类的请求，并将在 foo/ 下向您显示 index.html。如果您更喜欢从 *.md 到 *.html 的严格映射，您可以通过将 uglyURLs 设置为 true 来启用 “ugly” URLs。 hasCJKLanguage: 如果您的网站主要是 CJK（中文、韩文和日文），我建议您将此选项设置为 true，以便 Hugo 的自动摘要和字数统计效果更好。 除了内置的 Hugo 选项外，您还可以在 config.toml 中设置其他任意选项。例如，很常见的是名为 params 的选项，它广泛应用于许多 Hugo 主题中。当您在 Hugo 主题中看到变量 .Site.Params.FOO 时，它表示您在 config.toml 中的 [params] 下设置的选项 FOO，例如 .Site.Params.author 是 Frida Gomam，具有以下配置文件： [params] author = &quot;Frida Gomam&quot; dateFormat = &quot;2006/01/02&quot; 所有这些选项的目标是避免对 Hugo 主题中的任何内容进行硬编码，以便用户可以轻松编辑单个配置文件以将主题应用到他们的网站，而不是浏览许多 HTML 文件并逐一进行更改。 Hugo 也支持 config.json，但 blogdown 不支持，所以我们不建议您使用它。↩︎ TOML 有它的优点，但我觉得它们在 Hugo 网站的背景下并不重要。当 YAML 代表 “另一种标记语言” 时，必须了解另一种语言 TOML 是一种痛苦。我不确定 XKCD 漫画是否适用于这种情况：https://xkcd.com/927/。↩︎ slug 只是一个字符串，可用于标识特定的帖子。即使标题改变，slug 也不会改变。例如，如果您决定将帖子的标题从 “I love blogdown” 更改为 “Why blogdown is the best package ever”，并且您在 URL 中使用了该帖子的标题，那么您的旧链接现在将被破坏。相反，如果您通过 slug（类似于 “blogdown-love”）指定 URL，那么您可以根据需要多次更改标题，并且不会出现任何损坏的链接。↩︎ "],["content.html", "2.3 Content", " 2.3 Content content/ 目录的结构可以是任意的。常见的结构是 content/ 根目录下有一些静态页面，以及一个包含博客文章的子目录 post/： ├── _index.md ├── about.md ├── vitae.md ├── post/ │ ├── 2017-01-01-foo.md │ ├── 2017-01-02-bar.md │ └── ... └── ... 2.3.1 YAML metadata 每个页面都应以 YAML metadata 开头，指定标题、日期、作者、类别、标签等信息。根据您使用的特定 Hugo 主题和模板，其中一些字段可能是可选的。 在所有 YAML 字段中，我们希望引起您的注意： draft: 您可以通过在其 YAML metadata 中设置 draft: true 将文档标记为草稿。如果网站是通过 blogdown::build_site() 或 blogdown::hugo_build() 构建的，则不会呈现草稿帖子，但会在本地预览模式下呈现（请参阅 Section D.3）。 publishdate: 您可以指定发布帖子的未来日期。与草稿帖子类似，未来的帖子仅以本地预览模式呈现。 weight: 该字段可以采用数值来告诉 Hugo 排序时页面的顺序，例如，当您生成目录下所有页面的列表时，并且两个帖子具有相同的日期，您可以为它们分配不同的权重在列表中获取您想要的顺序。 slug: 作为 URL 尾部的字符串。当您为永久 URL 定义自定义规则时，它特别有用（请参阅 Section 2.2.2）。 2.3.2 Body 正如我们在 Section 1.6 中提到的，您的帖子可以用 R Markdown 或普通 Markdown 编写。当您编写帖子正文时，请注意两种格式之间的语法差异。 2.3.3 Shortcode 除了所有 Markdown 功能之外，Hugo 还提供了一个名为 “shortcodes” 的有用功能。您可以在帖子正文中使用 shortcode。当 Hugo 渲染帖子时，它可以根据您传递给 shortcode 的参数自动生成 HTML 片段。这很方便，因为您不必在帖子中键入或嵌入大量 HTML 代码。例如，Hugo 有一个内置的 shortcode，用于嵌入 Twitter 卡片。通常，这是在页面上嵌入 Twitter 卡（Figure 2.2）的方式： &lt;blockquote class=&quot;twitter-tweet&quot;&gt; &lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;Anyone know of an R package for interfacing with Alexa Skills? &lt;a href=&quot;https://twitter.com/thosjleeper&quot;&gt;@thosjleeper&lt;/a&gt; &lt;a href=&quot;https://twitter.com/xieyihui&quot;&gt;@xieyihui&lt;/a&gt; &lt;a href=&quot;https://twitter.com/drob&quot;&gt;@drob&lt;/a&gt; &lt;a href=&quot;https://twitter.com/JennyBryan&quot;&gt;@JennyBryan&lt;/a&gt; &lt;a href=&quot;https://twitter.com/HoloMarkeD&quot;&gt;@HoloMarkeD&lt;/a&gt; ? &lt;/p&gt; &amp;mdash; Jeff Leek (@jtleek) &lt;a href=&quot;https://twitter.com/jtleek/status/852205086956818432&quot;&gt; April 12, 2017 &lt;/a&gt; &lt;/blockquote&gt; &lt;script async src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt; &lt;/script&gt; FIGURE 2.2: A tweet by Jeff Leek. 如果您使用 shortcode，您在 Markdown 源文档中只需要： {{&lt; tweet user=&quot;jtleek&quot;, id=&quot;852205086956818432&quot; &gt;}} 基本上，您只需将推文的用户名和 ID 传递给名为 tweet 的 shortcode。6 Hugo 将自动获取推文并为您呈现 HTML 片段。有关 shortcodes 的更多信息，请参阅 https://gohugo.io/extras/shortcodes/。 Shortcodes 应该仅适用于纯 Markdown 文档。要在 R Markdown 中使用 shortcodes 而不是普通 Markdown，您必须调用函数 blogdown::shortcode()，例如， ```{r echo=FALSE} blogdown::shortcode( &quot;tweet&quot;, user = &quot;jtleek&quot;, id = &quot;852205086956818432&quot; ) ``` Hugo v0.89.0 之前，只需要传递 ID 即可。由于 Twitter 自 2021 年底开始要求用户名，这意味着如果您想使用 Twitter shortcode，则必须使用 Hugo &gt;= 0.89.0 并提供用户名。不幸的是，对于旧版本的 Hugo，shortcode 将被破坏。↩︎ "],["themes.html", "2.4 Themes", " 2.4 Themes Hugo 主题是模板文件和可选网站资源（例如 CSS 和 JavaScript 文件）的集合。简而言之，主题定义了通过模板呈现源内容后您的网站的外观。 Hugo 在 https://themes.gohugo.io 上提供了大量用户贡献的主题。除非您是经验丰富的网页设计师，否则最好从此处的现有主题开始。这些主题的质量和复杂性差异很大，您应该谨慎选择。例如，您可以查看某个主题存储库在 GitHub 上的星星数量，以及该存储库是否仍然相对活跃。长时间（例如几年）未更新的主题可能仍适用于更高版本的 Hugo，也可能不适用于。您必须仔细测试它们。 在本节中，我们将解释 blogdown 中的默认主题是如何工作的，这也可能会给您一些关于如何开始使用其他主题的想法。 2.4.1 The default theme blogdown 中的默认主题 hugo-lithium 托管在 GitHub 上：https://github.com/yihui/hugo-lithium。它最初是由 Jonathan Rutheiser 编写的，我对其进行了一些修改。这个主题适合那些喜欢简约风格，想要建立一个只有几个页面和一些博客文章的网站的人。 通常，GitHub 上的主题存储库有一个 README 文件，该文件也用作主题的文档。阅读完后，下一个要查找的文件是 exampleSite 目录下的 config.toml，其中包含基于此主题的网站的示例配置。如果主题没有 README 文件或 exampleSite 目录，您可能不应该使用它。 主题 hugo-lithium 的 config.toml 包含以下选项： baseurl = &quot;/&quot; relativeurls = false languageCode = &quot;en-us&quot; title = &quot;A Hugo website&quot; theme = &quot;hugo-lithium&quot; ignoreFiles = [&quot;\\\\.Rmd$&quot;, &quot;\\\\.Rmarkdown&quot;, &quot;_files$&quot;, &quot;_cache$&quot;] [permalinks] post = &quot;/:year/:month/:day/:slug/&quot; [[menu.main]] name = &quot;About&quot; url = &quot;/about/&quot; [[menu.main]] name = &quot;GitHub&quot; url = &quot;https://github.com/rstudio/blogdown&quot; [[menu.main]] name = &quot;Twitter&quot; url = &quot;https://twitter.com/rstudio&quot; [params] description = &quot;A website built through Hugo and blogdown.&quot; highlightjsVersion = &quot;9.12.0&quot; highlightjsCDN = &quot;//cdnjs.cloudflare.com/ajax/libs&quot; highlightjsLang = [&quot;r&quot;, &quot;yaml&quot;] highlightjsTheme = &quot;github&quot; MathJaxCDN = &quot;//cdnjs.cloudflare.com/ajax/libs&quot; MathJaxVersion = &quot;2.7.5&quot; [params.logo] url = &quot;logo.png&quot; width = 50 height = 50 alt = &quot;Logo&quot; 其中一些选项可能很容易理解，而另一些可能需要解释： baseurl: 当您拥有网站的域名后，您可以稍后配置此选项。不要忘记结尾的斜杠。 relativeurls: 这是可选的。仅当您打算通过文件查看器在本地查看您的网站时，您可能才需要将其设置为 true，例如，双击 HTML 文件并在浏览器中查看它。该选项在 Hugo 中默认为 false，这意味着您的网站必须通过 Web 服务器查看，例如 blogdown::serve_site() 提供了本地 Web 服务器，因此当 relativeurls = false 时您可以在本地预览您的网站。 title: 您网站的标题。通常，它显示在网络浏览器的标题栏或页面选项卡上。 theme: 主题的目录名称。更改主题时需要非常小心，因为一个主题在配置方面可能与另一个主题截然不同。不同的主题很可能不适用于您当前的 config.toml。同样，您必须阅读主题的文档才能了解支持或需要哪些选项。 ignoreFiles and permalinks: 这些选项已在 Section 2.2.2 中进行了解释。 menu: 此选项列表指定顶部菜单项的文本和 URL。见 Figure ?? 获取示例页面。您可以更改或添加更多菜单项。如果您想排序项目，您可以为每个项目分配一个 weight，例如， [[menu.main]] name = &quot;Home&quot; url = &quot;/&quot; weight = 1 [[menu.main]] name = &quot;About&quot; url = &quot;/about/&quot; weight = 2 [[menu.main]] name = &quot;GitHub&quot; url = &quot;https://github.com/rstudio/blogdown&quot; weight = 3 [[menu.main]] name = &quot;CV&quot; url = &quot;/vitae/&quot; weight = 4 [[menu.main]] name = &quot;Twitter&quot; url = &quot;https://twitter.com/rstudio&quot; weight = 5 上面的例子中，我添加了一个菜单项 CV，URL 为 /vitae/，在 content/ 目录下应该有对应的源文件 vitae.md 来生成页面 /vitae/index.html，所以链接会真正发挥作用。 params: 主题的其他参数。 description: 您网站的简短描述。它在网页上不可见（您只能从 HTML 源代码中看到它），但应该向搜索引擎提供有关您网站的提示。 highlightjs*: 这些选项用于配置 JavaScript library highlight.js 以对网页上的代码块进行语法高亮显示。您可以更改版本（例如，9.12.0）、CND host（例如，使用 cdnjs: //cdnjs.cloudflare.com/ajax/libs）、添加更多语言（例如，[\"r\", \"yaml\", \"tex\"]），并更改主题（例如，atom-one-light）。请参阅 https://highlightjs.org/static/demo/ 了解 highlight.js 支持的所有语言和主题。 MathJax*: JavaScript library MathJax 可以在网页上呈现 LaTeX 数学表达式。与 highlightjsCDN 类似，您可以指定 MathJax 的 CDN host，例如 //cdnjs.cloudflare.com/ajax/libs，也可以指定 MathJax 的版本。 logo: 用于定义网站 logo 的选项列表。默认使用 static/ 目录下的 logo.png 图片。 如果你想成为一名主题开发人员并完全了解有关这些选项的所有技术细节，你必须了解 Hugo 模板，我们将在 Section 2.5 中介绍。 "],["templates.html", "2.5 Templates", " 2.5 Templates Hugo 主题由两个主要组件组成：templates 和 web assets。前者是必不可少的，它告诉 Hugo 如何渲染页面。7 后者是可选的，但也很重要。它通常由 CSS 和 JavaScript 文件以及图像和视频等其他资源组成。这些资源决定了您网站的外观和功能，有些资源可能嵌入到您的网页内容中。 您可以从官方文档（https://gohugo.io/templates/overview/）了解有关 Hugo 模板的更多信息。有很多不同类型的模板。为了让你更容易掌握关键思想，我创建了一个非常小的 Hugo 主题，它涵盖了普通用户可能需要的大部分功能，但总行数只有 150 行左右，所以我们可以在以下小节中谈论该主题的所有源代码。 2.5.1 A minimal example XMin 是一个 Hugo 主题，我花了大约 12 个小时从头开始编写。大约花了半个小时在模板上，花了 3.5 个小时在调整 CSS 样式上，花了 8 个小时在文档上（https://xmin.yihui.org）。我想这可能是一个代表性的案例，说明你在设计主题时会在每个部分花费多少时间。也许我们的本性是花更多的时间在 CSS 之类的装饰性内容上，而不是模板之类的基本内容上。同时，编码通常比文档更容易。 我们将展示 XMin 主题的源代码。由于主题将来可能会偶尔更新，因此您可以通过以下链接获取我们将在本节中讨论的固定版本：https://github.com/yihui/hugo-xmin/tree/4bb305。下面是主题中所有文件和目录的树形视图： hugo-xmin/ ├── LICENSE.md ├── README.md ├── archetypes │ └── default.md ├── layouts │ ├── 404.html │ ├── _default │ │ ├── list.html │ │ ├── single.html │ │ └── terms.html │ └── partials │ ├── foot_custom.html │ ├── footer.html │ ├── head_custom.html │ └── header.html ├── static │ └── css │ ├── fonts.css │ └── style.css └── exampleSite ├── config.toml ├── content │ ├── _index.md │ ├── about.md │ ├── note │ │ ├── 2017-06-13-a-quick-note.md │ │ └── 2017-06-14-another-note.md │ └── post │ ├── 2015-07-23-lorem-ipsum.md │ └── 2016-02-14-hello-markdown.md ├── layouts │ └── partials │ └── foot_custom.html └── public └── ... LICENSE.md 和 README.md 不是主题的必需组件，但您绝对应该为源代码选择许可证，以便其他人可以正确使用您的代码，并且 README 可以是您的软件的简短文档。 文件 archetypes/default.md 定义了用户可以创建新帖子的默认模板。在此主题中，default.md 仅提供空的 YAML metadata： --- --- 主题中最重要的目录是 layouts/ 和 static/。HTML 模板存储在 layouts/ 下，assets 存储在 static/ 下。 要理解 layouts/，你必须了解一些关于 HTML 的基础知识（参见 Section B.1），因为该目录下的模板大多是 HTML 文档或片段。在 layouts/ 下有很多可能的子目录类型，但我们这里只介绍两种：_default/ 和 partials/。 _default/ 目录是放置网页默认模板的位置。在 XMin 主题中，我们有三个模板：single.html、list.html 和 terms.html。 single.html 是用于渲染单个页面的模板。单个页面基本上对应于 content/ 下的 Markdown 文档，它包含 (YAML) metadata 和 content。通常我们想要呈现页面标题、作者、日期和内容。下面是 XMin 的 single.html 的源代码： {{ partial &quot;header.html&quot; . }} &lt;div class=&quot;article-meta&quot;&gt; &lt;h1&gt;&lt;span class=&quot;title&quot;&gt;{{ .Title }}&lt;/span&gt;&lt;/h1&gt; {{ with .Params.author }} &lt;h2 class=&quot;author&quot;&gt;{{ . }}&lt;/h2&gt; {{ end }} {{ if .Params.date }} &lt;h2 class=&quot;date&quot;&gt;{{ .Date.Format &quot;2006/01/02&quot; }}&lt;/h2&gt; {{ end }} &lt;/div&gt; &lt;main&gt; {{ .Content }} &lt;/main&gt; {{ partial &quot;footer.html&quot; . }} 您会看到很多对双花括号 {{}}，这就是您使用 Hugo 的变量和函数对模板进行编程的方式。 该模板以部分模板 header.html 开头，您很快就会看到其源代码。现在，您可以将其想象为页面 body 之前的所有 HTML 标记（例如 &lt;html&gt;&lt;head&gt;）。部分模板主要是为了重用 HTML 代码。例如，所有 HTML 页面可能共享非常相似的 &lt;head&gt;&lt;/head&gt; 标记，您可以将公共部分分解为部分模板。 页面的 metadata 包含在带有 article-meta 类的 &lt;div&gt; 元素中。我们建议您在设计模板时为 HTML 元素分配 classes，以便更轻松地使用 class names 将 CSS 样式应用到这些元素。在模板中，您可以访问 Hugo 提供的许多变量，例如 .Title 变量存储页面标题的值，我们将标题写在第一级标题 &lt;h1&gt; 中的 &lt;span&gt; 中。同样，作者和日期也写在 &lt;h2&gt; 中，但前提是它们在 YAML metadata 中提供。语法 {{ with FOO }}{{ . }}{{ end }} 是 {{if FOO }}{{ FOO }}{{ end }} 的简写，即，使用 {{ . }} 可以省去两次键入表达式 FOO 的麻烦。方法 .Format 可以应用于日期对象，在本主题中，我们将日期格式化为 YYYY/mm/dd 形式（2006/01/02 是 Go 中指定格式的方式）。 然后我们显示页面的内容，该内容存储在变量 .Content 中。内容包含在语义 HTML 标记 &lt;main&gt; 中。 在我们添加另一个部分模板 footer.html （源代码很快就会显示）后，模板就完成了。 为了更容易理解模板的工作原理，我们在下面展示了一个最小的示例文章： --- title: Hello World author: Frida Gomam date: 2017-06-19 --- A single paragraph. 使用模板 single.html，它将转换为 HTML 页面，其源代码看起来或多或少像这样（省略了页眉和页脚）： &lt;div class=&quot;article-meta&quot;&gt; &lt;h1&gt;&lt;span class=&quot;title&quot;&gt;Hello World&lt;/span&gt;&lt;/h1&gt; &lt;h2 class=&quot;author&quot;&gt;Frida Gomam&lt;/h2&gt; &lt;h2 class=&quot;date&quot;&gt;2017/06/19&lt;/h2&gt; &lt;/div&gt; &lt;main&gt; &lt;p&gt;A single paragraph.&lt;/p&gt; &lt;/main&gt; 有关单个页面的完整示例，您可以查看 https://xmin.yihui.org/about/。 list.html 是用于呈现页面列表的模板，例如博客文章列表或类别或标签内的页面列表。这是它的源代码： {{ partial &quot;header.html&quot; . }} {{if not .IsHome }} &lt;h1&gt;{{ .Title }}&lt;/h1&gt; {{ end }} {{ .Content }} &lt;ul&gt; {{ range (where .Data.Pages &quot;Section&quot; &quot;!=&quot; &quot;&quot;) }} &lt;li&gt; &lt;span class=&quot;date&quot;&gt;{{ .Date.Format &quot;2006/01/02&quot; }}&lt;/span&gt; &lt;a href=&quot;{{ .URL }}&quot;&gt;{{ .Title }}&lt;/a&gt; &lt;/li&gt; {{ end }} &lt;/ul&gt; {{ partial &quot;footer.html&quot; . }} 同样，它使用两个部分模板 header.html 和 footer.html。表达式 {{if not .IsHome }} 的意思是，如果该列表不是主页，则显示页面标题。这是因为我不想在主页上显示标题。这只是我个人的喜好。如果您愿意，您当然可以在主页的 &lt;h1&gt; 中显示标题。 {{ .Content }} 显示列表的内容。请注意，通常 .Content 为空，这可能会令人惊讶。这是因为默认情况下不会从源 Markdown 文件生成列表页面。然而，有一个例外。当你在列表名对应的目录下编写一个特殊的 Markdown 文件 _index.md 时，列表的 .Content 将是这个 Markdown 文件的内容。例如，您可以在 content/_index.md 中定义您的主页内容，在 content/post/_index.md 中定义帖子列表页面的内容。 接下来，我们使用循环（range）生成列表，该列表通过按页面部分不应为空的条件过滤的所有页面。Hugo 中的 “Section” 是指 content/ 下的一级子目录名称。例如，content/post/foo.md 的部分是 post。因此，过滤器意味着我们将列出 content/ 子目录下的所有页面。这将排除根 content/ 目录下的页面，例如 content/about.md。 请注意，变量 .Data 是动态的，其值根据您要生成的特定列表而变化。例如，列表页面 https://xmin.yihui.org/post/ 仅包含 content/post/ 下的页面，https://xmin.yihui.org/note/ 仅包含 content/note/ 下的页面。这些列表页面是由 Hugo 自动生成的，您不需要显式循环浏览 post 和 note 部分。也就是说，单个模板 list.html 将根据您网站上的部分和分类术语（例如类别和标签）生成多个页面列表。 列表项由 &lt;ul&gt; 中的 HTML 标记 &lt;li&gt; 表示。每个项目由日期、链接和页面标题组成。您可以查看 https://xmin.yihui.org/post/ 以获取列表页面的完整示例。 terms.html 是分类术语主页的模板。例如，您可以使用它来生成类别或标签的完整列表。源代码如下： {{ partial &quot;header.html&quot; . }} &lt;h1&gt;{{ .Title }}&lt;/h1&gt; &lt;ul class=&quot;terms&quot;&gt; {{ range $key, $value := .Data.Terms }} &lt;li&gt; &lt;a href=&#39;{{ (print &quot;/&quot; $.Data.Plural &quot;/&quot; $key) | relURL }}&#39;&gt; {{ $key }} &lt;/a&gt; ({{ len $value }}) &lt;/li&gt; {{ end }} &lt;/ul&gt; {{ partial &quot;footer.html&quot; . }} 与 list.html 类似，它也使用循环。变量 .Data.Terms 存储分类法下的所有术语，例如所有类别名称。您可以将其视为 R 中的命名列表（在 Go 中称为 map），其中名称是术语，值是页面列表。变量 $key 表示术语，$value 表示与该术语关联的页面列表。我们在每个 &lt;li&gt; 中渲染的是术语页面的链接以及使用该术语的帖子数（len 是一个返回对象长度的 Go 函数）。 Hugo 自动渲染所有分类页面，路径名称是分类的复数形式，例如 https://xmin.yihui.org/categories/ 和 https://xmin.yihui.org/tags/。这就是 .Data.Plural 的含义。前导 $ 是必需的，因为我们位于循环内部，并且需要从外部范围访问变量。该术语的链接通过管道 | 传递给 Hugo 函数 relURL 使其相对，这是一个很好的做法，因为相对链接更可移植（独立于域名）。 partials/ 目录是放置 HTML 片段的地方，以便其他模板通过 partial 函数重用。该目录下有四个部分模板： header.html 主要定义 &lt;head&gt; 标签和 &lt;nav&gt; 标签中的导航菜单。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;{{ .Site.LanguageCode }}&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;{{ .Title }} | {{ .Site.Title }}&lt;/title&gt; &lt;link href=&#39;{{ &quot;/css/style.css&quot; | relURL }}&#39; rel=&quot;stylesheet&quot; /&gt; &lt;link href=&#39;{{ &quot;/css/fonts.css&quot; | relURL }}&#39; rel=&quot;stylesheet&quot; /&gt; {{ partial &quot;head_custom.html&quot; . }} &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;ul class=&quot;menu&quot;&gt; {{ range .Site.Menus.main }} &lt;li&gt;&lt;a href=&quot;{{ .URL | relURL }}&quot;&gt;{{ .Name }}&lt;/a&gt;&lt;/li&gt; {{ end }} &lt;/ul&gt; &lt;hr/&gt; &lt;/nav&gt; 如果您熟悉 HTML，&lt;head&gt; 区域应该很容易理解。请注意，我们还包含了一个部分模板 head_custom.html，该模板在此主题中为空，但它将使用户更容易向 &lt;head&gt; 添加自定义代码，而无需重写整个模板。更多详细信息请参见 Section 2.6。 导航菜单本质上是一个列表，列表中的每个项目都是从变量 .Site.Menus.main 中读取的。这意味着用户可以在 config.toml 中定义菜单，例如， [[menu.main]] name = &quot;Home&quot; url = &quot;/&quot; [[menu.main]] name = &quot;About&quot; url = &quot;/about/&quot; 它会生成一个像这样的菜单： &lt;ul class=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/about/&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; Hugo 拥有强大的菜单系统，而我们在这个主题中只使用了最简单的菜单类型。如果您对嵌套菜单等更多功能感兴趣，请参阅 http://gohugo.io/extras/menus/ 上的完整文档。 footer.html 定义页面的页脚区域并关闭 HTML 文档： &lt;footer&gt; {{ partial &quot;foot_custom.html&quot; . }} {{ with .Site.Params.footer }} &lt;hr/&gt; {{ . | markdownify }} {{ end }} &lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; 部分模板 foot_custom.html 的用途与 head_custom.html 相同；也就是说，允许用户向 &lt;footer&gt; 添加自定义代码，而无需重写整个模板。 最后，我们使用变量 .Site.Params.footer 生成页脚。请注意，我们再次使用了 with 函数。回想一下语法 {{ with .Site.Params.footer }}{{ . }}{{ end }} 是 {{if .Site.Params.footer }}{{ .Site.Params.footer }}{{ end }} 的简写。此语法使您无需使用 {{ . }} 两次键入表达式 .Site.Params.footer 作为变量 footer 的占位符，它在我们的 config.toml 文件中定义为站点参数。附加函数 markdownify 可以将 Markdown 转换为 HTML（即 {{ . | markdownify }}）。总而言之，这个序列意味着我们可以在 config.toml 中的 params 下使用 Markdown 定义 footer 选项，例如， [params] footer = &quot;&amp;copy; [Yihui Xie](https://yihui.org) 2017&quot; 有一个特殊的模板 404.html，Hugo 使用它来创建 404 页面（当找不到页面时，显示此页面）： {{ partial &quot;header.html&quot; . }} 404 NOT FOUND {{ partial &quot;footer.html&quot; . }} 使用上述所有模板，我们将能够从 Markdown 源文件生成一个网站。但是，您不太可能对该网站感到满意，因为 HTML 元素根本没有样式，并且默认外观可能对大多数人来说并不有吸引力。您可能已经注意到，在 header.html 中，我们包含了两个 CSS 文件：/css/style.css 和 /css/fonts.css。 您可以在线找到许多可应用于 Hugo 主题的现有开源 CSS 框架。例如，最流行的 CSS 框架可能是 Bootstrap：http://getbootstrap.com。当我设计 XMin 时，我想知道在不使用这些现有框架的情况下我能走多远，因为它们通常非常大。例如，bootstrap.css 在未最小化时有近 10000 行代码。事实证明，我用了大约 50 行 CSS 就能够得到满意的外观，下面我将详细解释： style.css 定义除字体之外的所有样式： body { max-width: 800px; margin: auto; padding: 1em; line-height: 1.5em; } 页面主体的最大宽度设置为 800 像素，因为过宽的页面难以阅读（800 是我选择的任意阈值）。正文使用 CSS 技巧 margin: auto 居中，这意味着顶部、右侧、底部和左侧边距是自动的。当块元素的左右边距为 auto 时，它将居中。 /* header and footer areas */ .menu li { display: inline-block; } .article-meta, .menu a { text-decoration: none; background: #eee; padding: 5px; border-radius: 5px; } .menu, .article-meta, footer { text-align: center; } .title { font-size: 1.1em; } footer a { text-decoration: none; } hr { border-style: dashed; color: #ddd; } 请记住，我们的菜单元素是 header.html 中定义的列表 &lt;ul class=\"menu\"&gt;。我将菜单中 &lt;li&gt; 的默认显示样式更改为 inline-block，以便它们将作为内联元素从左到右布局，而不是作为项目符号列表垂直堆叠（默认行为）。 对于菜单中的链接 (&lt;a&gt;) 和文章的 metadata 区域，将删除默认文本修饰（下划线），并应用浅色背景颜色。border radius 设置为 5 pixels，以便您可以看到每个链接后面有一个微妙的圆角矩形。 水平线 (&lt;hr&gt;) 设置为浅灰色虚线，以使其在页面上不那么突出。这些规则用于将文章正文与页眉和页脚区域分开。 /* code */ pre { border: 1px solid #ddd; box-shadow: 5px 5px 5px #eee; padding: 1em; overflow-x: auto; } code { background: #f9f9f9; } pre code { background: none; } 对于代码块 (&lt;pre&gt;)，我应用带有阴影效果的浅灰色边框。每个内联代码元素都有一个非常浅的灰色背景。这些装饰仅仅是出于我自己对代码的特殊兴趣和重视。 /* misc elements */ img, iframe, video { max-width: 100%; } main { hyphens: auto; } blockquote { background: #f9f9f9; border-left: 5px solid #ccc; padding: 3px 1em 3px; } table { margin: auto; border-top: 1px solid #666; border-bottom: 1px solid #666; } table thead th { border-bottom: 1px solid #ddd; } th, td { padding: 5px; } tr:nth-child(even) { background: #eee } 超出页边距的嵌入元素（例如图像和视频）通常很难看，因此我将它们的最大宽度限制为 100%。&lt;main&gt; 中的单词连字符已打开。块引用有一个灰色的左侧边栏和浅灰色的背景。表格默认居中，只有三个水平线：表格的顶部和底部边框以及表格标题的底部边框。表格行呈条纹状，以便于阅读表格，尤其是当表格很宽时。 fonts.css 是一个单独的样式表，因为它在网站的外观中起着至关重要的作用，并且您很可能想要自定义此文件。在大多数情况下，您的读者会花费最多的时间阅读页面上的文本，因此使文本易于阅读非常重要。我不是网页设计方面的专家，我只是选择 Palatino 作为正文，并选择 Lucida Console 或 Monaco（以您的系统中可用的为准）作为代码。现在使用谷歌网络字体很常见。您可以尝试一些网络字体，看看是否喜欢其中的任何一个。 body { font-family: &quot;Palatino Linotype&quot;, &quot;Book Antiqua&quot;, Palatino, serif; } code { font-family: &quot;Lucida Console&quot;, Monaco, monospace; font-size: 85%; } 这两个 CSS 文件放在主题的 static/css/ 目录下。在 HTML 模板 header.html 中，路径 /css/style.css 引用文件 static/css/style.css。 最后，该主题在 exampleSite/ 下提供了一个示例站点。目录结构可能有点混乱，因为这是一个主题而不是网站。实际上，exampleSite/ 下的所有内容都应该在网站的根目录下，并且顶级的 hugo-xmin/ 目录应该在该网站的 themes/ 目录下，即： ├── config.toml ├── content/ ├── ... ├── themes/ │ └── hugo-xmin/ │ └── ... 示例站点提供了示例 config.toml、主页 _index.md、关于页面 about.md、note/ 下的两篇文章和 post/ 下的两篇文章。它还覆盖主题中的 foot_custom.html。 2.5.2 Implementing more features XMin 实际上是一个功能强大的主题，但我们知道它对您来说可能太小了。该主题（故意）缺少一些常用功能，如果需要，我们将教您如何自行添加它们。所有这些功能和源代码也可以应用于其他主题。 Enable Google Analytics. Hugo 提供了内置的部分模板。对于 XMin，您可以添加 {{ template &quot;_internal/google_analytics.html&quot; . }} 到网站根目录下的 layouts/partials/foot_custom.html（而不是 themes/hugo-xmin/），并在 config.toml 中配置 googleAnalytics。有关详细信息，请参阅 https://github.com/yihui/hugo-xmin/pull/3，以及从模板呈现的 JavaScript 的此页面的 HTML 源代码：https://deploy-preview-3--hugo-xmin.netlify.com。 Enable Disqus comments. 与 Google Analytics 类似，您可以添加内置模板 {{ template &quot;_internal/disqus.html&quot; . }} 到 foot_custom.html，并在 config.toml 中配置 Disqus 短名称。有关详细信息，请参阅 https://github.com/yihui/hugo-xmin/pull/4，并在 https://deploy-preview-4--hugo-xmin.netlify.com 上查看预览。 Enable syntax highlighting via highlight.js. 将这添加到 head_custom.html &lt;link href=&quot;//YOUR-CDN-LINK/styles/github.min.css&quot; rel=&quot;stylesheet&quot;&gt; 并将这添加到 foot_custom.html： &lt;script src=&quot;//YOUR-CDN-LINK/highlight.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//YOUR-CDN-LINK/languages/r.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; hljs.configure({languages: []}); hljs.initHighlightingOnLoad(); &lt;/script&gt; 请记住将 YOUR-CDN-LINK 替换为您首选的 highlight.js CDN 主机的链接，例如 cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0。有关 highlight.js 的更多信息，请参阅其主页：https://highlightjs.org。如果您需要使用其他 CDN 主机，cdnjs.com 是一个不错的选择：https://cdnjs.com/libraries/highlight.js 您还可以查看那里支持哪些语言和 CSS 主题。 您可能会看到 https://github.com/yihui/hugo-xmin/pull/5 的实际实现，以及 https://deploy-preview-5--hugo-xmin.netlify.com/post/2016/02/14/a-plain-markdown-post/ 上带有语法突出显示的示例页面。 Support math expressions through MathJax. 将以下代码添加到 foot_custom.html。 &lt;script src=&quot;//yihui.org/js/math-code.js&quot;&gt;&lt;/script&gt; &lt;script async src=&quot;//YOUR-CDN-LINK/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt; &lt;/script&gt; 这需要具备丰富的 JavaScript 知识并熟悉 MathJax 才能完全理解上面的代码，我们将把代码的解释留给 Section B.3。 请记住将 YOUR-CDN-LINK 替换为您首选的 MathJax CDN 主机的链接，例如 cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5。 Show the table of contents (TOC). 要显示 R Markdown 帖子的目录，您只需将输出格式 blogdown::html_page 和选项 toc: true 添加到 YAML： output: blogdown::html_page: toc: true 对于普通的 Markdown 帖子，您必须修改模板 single.html。帖子的目录存储在 Hugo 模板变量 .TableOfContents 中。您可能需要一个选项来控制是否显示目录，例如，您可以将选项 toc: true 添加到 Markdown 帖子的 YAML metadata 中以显示目录。可以在 single.html 中的帖子内容之前添加以下代码： {{ if .Params.toc }} {{ .TableOfContents }} {{ end }} 请参阅 https://github.com/yihui/hugo-xmin/pull/7 了解示例实现。 Display categories and tags in a post if provided in its YAML. 在 single.html 中要放置类别和标签的位置添加下面的代码，例如，在 &lt;div class=\"article-meta\"&gt;&lt;/div&gt; 中。 &lt;p class=&quot;terms&quot;&gt; {{ range $i := (slice &quot;categories&quot; &quot;tags&quot;) }} {{ with ($.Param $i) }} {{ $i | title }}: {{ range $k := . }} &lt;a href=&#39;{{ relURL (print &quot;/&quot; $i &quot;/&quot; $k | urlize) }}&#39;&gt;{{$k}}&lt;/a&gt; {{ end }} {{ end }} {{ end }} &lt;/p&gt; 基本上，代码循环遍历 YAML metadata 字段 categories 和 tags，对于每个字段，其值从 .Param 获取，然后我们使用内部循环以 &lt;a href=\"/tags/foo/\"&gt;foo&lt;/a&gt; 形式的链接写出术语。 您可以在 https://github.com/yihui/hugo-xmin/pull/2 上查看完整的实现和预览在 https://deploy-preview-2--hugo-xmin.netlify.com/post/2016 /02/14/a-plain-markdown-post/。 Add pagination. 当网站上有大量帖子时，您可能不希望在单个页面上显示完整列表，而是每页显示 N 个帖子（例如，N = 10）。使用 Hugo 的内置函数和模板可以轻松地向网站添加分页。您无需循环遍历列表模板中的所有帖子（例如 range .Data.Pages），而是使用函数 .Paginate 对完整的帖子列表进行分页（例如 range (.Paginate .Data.Pages)）。下面是一个模板片段，您可以将其插入到模板文件 list.html 中： &lt;ul&gt; {{ $paginator := .Paginate .Data.Pages }} {{ range $paginator.Pages }} &lt;li&gt; &lt;span class=&quot;date&quot;&gt;{{ .Date.Format &quot;2006/01/02&quot; }}&lt;/span&gt; &lt;a href=&quot;{{ .URL }}&quot;&gt;{{ .Title }}&lt;/a&gt; &lt;/li&gt; {{ end }} &lt;/ul&gt; {{ template &quot;_internal/pagination.html&quot; . }} 完整实现请参见 https://github.com/yihui/hugo-xmin/pull/16。 Add a GitHub Edit button or link to a page. 如果上述功能对您来说都不令人兴奋（这不会让我感到惊讶），那么这个小功能确实是一个很好的例子，它向您展示了纯文本文件和静态网站与 GitHub（或其他支持纯文本文件在线编辑的服务）结合使用时的强大功能。我相信在 WordPress 这样的动态网站框架中实现这个功能即使不是不可能，也是很困难的。 基本上，当您浏览 GitHub 上存储库中的任何文本文件时，如果您有 GitHub 帐户，则可以通过单击 Edit 按钮直接在页面上编辑它们（示例见 Figure 2.3）。如果您对存储库有写权限，则可以直接在线提交更改，否则 GitHub 会自动为您 fork 存储库，以便您可以在自己的存储库中编辑文件，并且 GitHub 会引导您创建 pull request 原始存储库。当原所有者看到 pull request 时，他/她可以看到您所做的更改并决定是否接受它们或要求您进行进一步的更改。尽管术语 “pull request” 对初学者来说非常令人困惑，8 它可能是 GitHub 发明的最伟大的功能，因为它使人们更容易做出贡献。 真正方便的是，您只需要一个固定形式的 URL 即可编辑 GitHub 上的文件：https://github.com/USER/REPO/edit/BRANCH/PATH/TO/FILE。例如，https://github.com/rbind/yihui/edit/master/content/knitr/faq.md，其中 USER 为 rbind，REPO 为 yihui，BRANCH 为 master，文件路径为 content/knitr/faq.md。 实现此功能的关键是变量 .File.Path，它为我们提供了 content/ 下页面的源文件路径，例如 post/foo.md。如果您的网站仅使用纯 Markdown 文件，那么实现将非常简单。我在下面的 ... 中省略了完整的 GitHub URL，其中一个示例可以是 https://github.com/rbind/yihui/edit/master/content/。 {{ with .File.Path }} &lt;a href=&quot;https://github.com/.../{{ . }}&quot;&gt;Edit this page&lt;/a&gt; {{ end }} 然而，当涉及 R Markdown 帖子时，对于 blogdown 用户来说，情况会稍微复杂一些。您不能只使用 .File.Path，因为它实际上指向 .Rmd 文件的 .html 输出文件，而 .Rmd 文件是实际的源文件。编辑按钮或链接不应指向 .html 文件。以下是完整的实现，您可以根据您想要显示编辑链接的位置（例如 footer.html）将其添加到模板文件中： {{ if .File.Path }} {{ $Rmd := (print .File.BaseFileName &quot;.Rmd&quot;) }} {{ if (where (readDir (print &quot;content/&quot; .File.Dir)) &quot;Name&quot; $Rmd) }} {{ $.Scratch.Set &quot;FilePath&quot; (print .File.Dir $Rmd) }} {{ else }} {{ $.Scratch.Set &quot;FilePath&quot; .File.Path }} {{ end }} {{ with .Site.Params.GithubEdit}} &lt;a href=&#39;{{ . }}{{ $.Scratch.Get &quot;FilePath&quot; }}&#39;&gt;Edit this page&lt;/a&gt; {{ end }} {{ end }} 基本逻辑是，对于一个文件，如果存在扩展名为 .Rmd 的相同文件名，我们会将编辑链接指向该 Rmd 文件。首先，我们定义变量 $Rmd 作为扩展名为 .Rmd 的文件名。然后我们检查它是否存在。不幸的是，Hugo 中没有像 R 中的 file.exists() 这样的函数，所以我们必须使用一个 hack：列出目录下的所有文件，并查看 Rmd 文件是否在列表中。$.Scratch 是 Hugo 模板中动态存储和获取变量的方式。Hugo 中的大多数变量都是只读的，当你想修改变量时你必须使用 $.Scratch。我们在 $.Scratch 中设置一个变量 FilePath，当 Rmd 文件存在时，其值为 Rmd 文件的完整路径，否则为 Markdown 源文件的路径。最后，我们将 config.toml 中的自定义选项 GithubEdit 与文件路径连接起来，完成编辑链接 &lt;a&gt;。以下是 config.toml 中的选项示例： [params] GithubEdit = &quot;https://github.com/rbind/yihui/edit/master/content/&quot; 请注意，如果您在 Windows 上使用 Hugo 来构建和部署站点，您可能需要将文件路径分隔符从反斜杠更改为正斜杠，例如，您可能需要 {{ $.Scratch.Set \"FilePath\" (replace ($.Scratch.Get \"FilePath\") \"\\\\\" \"/\") }} 在模板中。为了避免这种复杂情况，我们不建议您通过 Windows 部署站点（有关部署方法，请参阅 Chapter 3）。 您可以查看 https://github.com/yihui/hugo-xmin/pull/6 以了解 R Markdown 示例的实际实现，并查看本页页脚的编辑链接：https://deploy-preview-6 –hugo-xmin.netlify.com。实际上，您可以在每个页面的页脚中看到一个链接，页面列表除外（因为它们没有源文件）。 FIGURE 2.3: Edit a text file online on GitHub. 当你消化了 XMin 主题和附加功能的实现后，理解其他人的模板应该会容易得多。Hugo 主题有很多，但它们之间的主要区别通常在于风格。模板的基本组件通常是相似的。 模板最常见的功能是呈现 HTML 页面，但也可以有特殊的模板，例如用于 RSS 提要和站点地图（它们是 XML 文件）的模板。↩︎ 在我看来，它确实应该被称为 “merge request”。↩︎ "],["custom-layouts.html", "2.6 Custom layouts", " 2.6 Custom layouts 您很可能想要自定义主题，除非您设计了它。最直接的方法是直接在主题中进行更改，9 但问题是 Hugo 主题可能会被其原作者不断更新以进行改进或错误修复。类似于 “you break it, you buy it” 的政策（the Pottery Barn rule），一旦你接触了别人的源代码，你将负责其未来的维护，而原作者不应对你所做的更改负责在你身边。这意味着将该主题的未来更新拉到您的网站可能并不容易（您必须仔细阅读更改并确保它们不会与您的更改冲突），但如果您对主题的当前状态完全满意并且不想以后更新，直接修改主题文件就可以了。 意识到用户可以自定义主题的主题作者通常会提供两种方法：一种是在 config.toml 中提供选项，以便您可以在不接触模板文件的情况下更改这些选项；另一种是在主题中的 layouts/ 下留下一些轻量级模板文件，这样你就可以覆盖它们而无需触及核心模板文件。以 XMin 主题为例： 我在主题中的 layouts/partials/ 下有两个空的 HTML 文件 head_custom.html 和 foot_custom.html。前者将添加到页面的 &lt;head&gt;&lt;/head&gt; 内，例如，您可以通过 &lt;link&gt; 加载 JavaScript 库或包含 CSS 样式表。后者将添加在页面页脚之前，例如，您可以加载其他 JavaScript 库或嵌入 Disqus comments。 自定义这两个文件的方式不是直接在主题文件夹中编辑它们，而是在网站根目录下创建一个目录 layouts/partials/，例如，您的目录结构可能如下所示： your-website/ ├── config.toml ├── ... ├── themes/ │ └── hugo-xmin/ │ ├── ... │ └── layouts/ │ ├── ... │ └── partials │ ├── foot_custom.html │ ├── footer.html │ ├── head_custom.html │ └── header.html └── layouts └── partials ├── foot_custom.html └── head_custom.html 根目录下的 layouts/ 下的所有文件将覆盖 themes/hugo-xmin/layouts/ 下具有相同相对路径的文件，例如文件 layouts/partials/foot_custom.html，如果提供，将覆盖 themes/hugo-xmin/layouts/partials/foot_custom.html。这意味着您只需要在 layouts/ 下创建和维护最多两个文件，而不是在 themes/ 下维护所有文件。请注意，此覆盖机制适用于 layouts/ 下的所有文件，并且不限 partials/ 目录。它还适用于您实际用于网站的任何 Hugo 主题，并且不限于 hugo-xmin。 如果您是 Web 开发新手，请小心更改主题内的内容。颜色和字体大小等细微更改可以在主题的 CSS 文件中找到，并且可以简单地进行更改，而破坏主题功能的风险最小。↩︎ "],["static-files.html", "2.7 Static files", " 2.7 Static files Hugo 渲染网站时，static/ 目录下的所有文件都会复制到 public/ 中。该目录通常用于存储静态 Web 资源，例如图像、CSS 和 JavaScript 文件。例如，可以使用 Markdown 语法 ![](/foo/bar.png) 将图像 static/foo/bar.png 嵌入到您的帖子中。10 通常主题有一个 static/ 文件夹，您可以使用与覆盖 layouts/ 文件相同的机制部分覆盖其文件，即 static/file 将覆盖 themes/theme-name/static/file。在 XMin 主题中，我有两个 CSS 文件 style.css 和 fonts.css。前者是主要样式表，后者是一个非常小的文件，仅用于定义字体。您可能想定义自己的字体，并且只能提供 static/css/fonts.css 来覆盖主题中的字体，例如， body { font-family: &quot;Comic Sans MS&quot;, cursive, sans-serif; } code { font-family: &quot;Courier New&quot;, Courier, monospace; } 对于 R Markdown 用户来说，static/ 目录的另一个重要应用是构建具有自定义输出格式的 Rmd 文档，即不使用 blogdown::html_page() 格式的 Rmd 文档（参见 Section 1.6）。例如，您可以从此目录下的 Rmd 文档生成 PDF 或演示文稿，这样 Hugo 就不会对其进行后期处理，而只是将其复制到 public/ 进行发布。要构建这些 Rmd 文件，您必须提供自定义构建脚本 R/build.R（请参阅 Section D.9）。您可以在此脚本中编写一行代码： blogdown::build_dir(&quot;static&quot;) 函数 build_dir() 查找目录下的所有 Rmd 文件，并调用 rmarkdown::render() 将它们构建为 Rmd 文件的 YAML metadata 中指定的输出格式。如果您的 Rmd 文件不应通过简单的 rmarkdown::render() 调用来呈现，您可以自由提供自己的代码以在 R/build.R 中呈现它们。函数 build_dir() 中有一个内置的缓存机制：如果 Rmd 文件早于其输出文件，则不会编译该文件。如果您不希望出现此行为，可以强制每次重新编译所有 Rmd 文件：build_dir(force = TRUE)。 我在 GitHub 存储库 yihui/blogdown-static, 中提供了一个最小的示例，您可以在 static/ 目录下找到两个 Rmd 示例。一个是基于 xaringan 包的 HTML5 演示文稿，另一个是基于 bookdown 的 PDF 文档。 由于 Hugo 的覆盖机制，您需要谨慎对待 static/ 下的任意文件。也就是说，static/ 下的所有内容都会被复制到 public/。您需要确保在 static/ 下渲染的文件不会与 Hugo 从 content/ 自动生成的文件冲突。例如，如果您同时有一个源文件 content/about.md 和一个 Rmd 文件 static/about/index.Rmd，则后者的 HTML 输出将覆盖前者（Hugo 和您都会生成一个输出文件具有相同的名称 public/about/index.html)。 图像的链接取决于您在 config.toml 中的 baseurl 设置。如果它不包含子路径，/foo/bar.png 将是图像的链接，否则你可能需要调整它，例如，对于 baseurl = \"http://example.com/subpath/\"，链接图像应该是 /subpath/foo/bar.png。↩︎ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
